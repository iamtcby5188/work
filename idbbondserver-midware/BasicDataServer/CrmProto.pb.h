// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CrmProto.proto

#ifndef PROTOBUF_CrmProto_2eproto__INCLUDED
#define PROTOBUF_CrmProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Crm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CrmProto_2eproto();
void protobuf_AssignDesc_CrmProto_2eproto();
void protobuf_ShutdownFile_CrmProto_2eproto();

class CommonRequestFields;
class CommonResponseFields;
class GetCrmIdListRequest;
class CrmIdItem;
class GetCrmIdListResponse;
class GetInstListRequest;
class InstitutionItem;
class GetInstListResponse;
class GetCtctListRequest;
class AccountMappingItem;
class ContactItem;
class GetCtctListResponse;
class GetAccountListRequest;
class AccountItem;
class GetAccountListResponse;
class GetRoleListRequest;
class RoleItem;
class GetRoleListResponse;
class GetTeamListRequest;
class TeamItem;
class GetTeamListResponse;
class AccountUpdateEvent;
class TeamUpdateEvent;
class InstitutionUpdateEvent;
class ContactUpdateEvent;
class ManagerUpdateEvent;

// ===================================================================

class CommonRequestFields : public ::google::protobuf::Message {
 public:
  CommonRequestFields();
  virtual ~CommonRequestFields();

  CommonRequestFields(const CommonRequestFields& from);

  inline CommonRequestFields& operator=(const CommonRequestFields& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonRequestFields& default_instance();

  void Swap(CommonRequestFields* other);

  // implements Message ----------------------------------------------

  CommonRequestFields* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonRequestFields& from);
  void MergeFrom(const CommonRequestFields& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  inline void set_allocated_request_id(::std::string* request_id);

  // optional bytes username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const void* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string currentAccountId = 4;
  inline bool has_currentaccountid() const;
  inline void clear_currentaccountid();
  static const int kCurrentAccountIdFieldNumber = 4;
  inline const ::std::string& currentaccountid() const;
  inline void set_currentaccountid(const ::std::string& value);
  inline void set_currentaccountid(const char* value);
  inline void set_currentaccountid(const char* value, size_t size);
  inline ::std::string* mutable_currentaccountid();
  inline ::std::string* release_currentaccountid();
  inline void set_allocated_currentaccountid(::std::string* currentaccountid);

  // optional int64 crm_id = 5;
  inline bool has_crm_id() const;
  inline void clear_crm_id();
  static const int kCrmIdFieldNumber = 5;
  inline ::google::protobuf::int64 crm_id() const;
  inline void set_crm_id(::google::protobuf::int64 value);

  // optional string application_type = 6;
  inline bool has_application_type() const;
  inline void clear_application_type();
  static const int kApplicationTypeFieldNumber = 6;
  inline const ::std::string& application_type() const;
  inline void set_application_type(const ::std::string& value);
  inline void set_application_type(const char* value);
  inline void set_application_type(const char* value, size_t size);
  inline ::std::string* mutable_application_type();
  inline ::std::string* release_application_type();
  inline void set_allocated_application_type(::std::string* application_type);

  // optional int32 page_size = 7 [default = 100];
  inline bool has_page_size() const;
  inline void clear_page_size();
  static const int kPageSizeFieldNumber = 7;
  inline ::google::protobuf::int32 page_size() const;
  inline void set_page_size(::google::protobuf::int32 value);

  // optional int32 page_number = 8 [default = 0];
  inline bool has_page_number() const;
  inline void clear_page_number();
  static const int kPageNumberFieldNumber = 8;
  inline ::google::protobuf::int32 page_number() const;
  inline void set_page_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Crm.CommonRequestFields)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_currentaccountid();
  inline void clear_has_currentaccountid();
  inline void set_has_crm_id();
  inline void clear_has_crm_id();
  inline void set_has_application_type();
  inline void clear_has_application_type();
  inline void set_has_page_size();
  inline void clear_has_page_size();
  inline void set_has_page_number();
  inline void clear_has_page_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* request_id_;
  ::std::string* username_;
  ::std::string* password_;
  ::std::string* currentaccountid_;
  ::google::protobuf::int64 crm_id_;
  ::std::string* application_type_;
  ::google::protobuf::int32 page_size_;
  ::google::protobuf::int32 page_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static CommonRequestFields* default_instance_;
};
// -------------------------------------------------------------------

class CommonResponseFields : public ::google::protobuf::Message {
 public:
  CommonResponseFields();
  virtual ~CommonResponseFields();

  CommonResponseFields(const CommonResponseFields& from);

  inline CommonResponseFields& operator=(const CommonResponseFields& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommonResponseFields& default_instance();

  void Swap(CommonResponseFields* other);

  // implements Message ----------------------------------------------

  CommonResponseFields* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommonResponseFields& from);
  void MergeFrom(const CommonResponseFields& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline const ::std::string& request_id() const;
  inline void set_request_id(const ::std::string& value);
  inline void set_request_id(const char* value);
  inline void set_request_id(const char* value, size_t size);
  inline ::std::string* mutable_request_id();
  inline ::std::string* release_request_id();
  inline void set_allocated_request_id(::std::string* request_id);

  // optional string return_code = 2;
  inline bool has_return_code() const;
  inline void clear_return_code();
  static const int kReturnCodeFieldNumber = 2;
  inline const ::std::string& return_code() const;
  inline void set_return_code(const ::std::string& value);
  inline void set_return_code(const char* value);
  inline void set_return_code(const char* value, size_t size);
  inline ::std::string* mutable_return_code();
  inline ::std::string* release_return_code();
  inline void set_allocated_return_code(::std::string* return_code);

  // optional string return_message = 3;
  inline bool has_return_message() const;
  inline void clear_return_message();
  static const int kReturnMessageFieldNumber = 3;
  inline const ::std::string& return_message() const;
  inline void set_return_message(const ::std::string& value);
  inline void set_return_message(const char* value);
  inline void set_return_message(const char* value, size_t size);
  inline ::std::string* mutable_return_message();
  inline ::std::string* release_return_message();
  inline void set_allocated_return_message(::std::string* return_message);

  // optional string return_count = 4;
  inline bool has_return_count() const;
  inline void clear_return_count();
  static const int kReturnCountFieldNumber = 4;
  inline const ::std::string& return_count() const;
  inline void set_return_count(const ::std::string& value);
  inline void set_return_count(const char* value);
  inline void set_return_count(const char* value, size_t size);
  inline ::std::string* mutable_return_count();
  inline ::std::string* release_return_count();
  inline void set_allocated_return_count(::std::string* return_count);

  // optional string page_info = 5;
  inline bool has_page_info() const;
  inline void clear_page_info();
  static const int kPageInfoFieldNumber = 5;
  inline const ::std::string& page_info() const;
  inline void set_page_info(const ::std::string& value);
  inline void set_page_info(const char* value);
  inline void set_page_info(const char* value, size_t size);
  inline ::std::string* mutable_page_info();
  inline ::std::string* release_page_info();
  inline void set_allocated_page_info(::std::string* page_info);

  // optional string message_id = 6;
  inline bool has_message_id() const;
  inline void clear_message_id();
  static const int kMessageIdFieldNumber = 6;
  inline const ::std::string& message_id() const;
  inline void set_message_id(const ::std::string& value);
  inline void set_message_id(const char* value);
  inline void set_message_id(const char* value, size_t size);
  inline ::std::string* mutable_message_id();
  inline ::std::string* release_message_id();
  inline void set_allocated_message_id(::std::string* message_id);

  // @@protoc_insertion_point(class_scope:Crm.CommonResponseFields)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_return_code();
  inline void clear_has_return_code();
  inline void set_has_return_message();
  inline void clear_has_return_message();
  inline void set_has_return_count();
  inline void clear_has_return_count();
  inline void set_has_page_info();
  inline void clear_has_page_info();
  inline void set_has_message_id();
  inline void clear_has_message_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* request_id_;
  ::std::string* return_code_;
  ::std::string* return_message_;
  ::std::string* return_count_;
  ::std::string* page_info_;
  ::std::string* message_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static CommonResponseFields* default_instance_;
};
// -------------------------------------------------------------------

class GetCrmIdListRequest : public ::google::protobuf::Message {
 public:
  GetCrmIdListRequest();
  virtual ~GetCrmIdListRequest();

  GetCrmIdListRequest(const GetCrmIdListRequest& from);

  inline GetCrmIdListRequest& operator=(const GetCrmIdListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCrmIdListRequest& default_instance();

  void Swap(GetCrmIdListRequest* other);

  // implements Message ----------------------------------------------

  GetCrmIdListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCrmIdListRequest& from);
  void MergeFrom(const GetCrmIdListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonRequestFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonRequestFields& common_fields() const;
  inline ::Crm::CommonRequestFields* mutable_common_fields();
  inline ::Crm::CommonRequestFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonRequestFields* common_fields);

  // @@protoc_insertion_point(class_scope:Crm.GetCrmIdListRequest)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonRequestFields* common_fields_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetCrmIdListRequest* default_instance_;
};
// -------------------------------------------------------------------

class CrmIdItem : public ::google::protobuf::Message {
 public:
  CrmIdItem();
  virtual ~CrmIdItem();

  CrmIdItem(const CrmIdItem& from);

  inline CrmIdItem& operator=(const CrmIdItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrmIdItem& default_instance();

  void Swap(CrmIdItem* other);

  // implements Message ----------------------------------------------

  CrmIdItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CrmIdItem& from);
  void MergeFrom(const CrmIdItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string crm_id = 1;
  inline bool has_crm_id() const;
  inline void clear_crm_id();
  static const int kCrmIdFieldNumber = 1;
  inline const ::std::string& crm_id() const;
  inline void set_crm_id(const ::std::string& value);
  inline void set_crm_id(const char* value);
  inline void set_crm_id(const char* value, size_t size);
  inline ::std::string* mutable_crm_id();
  inline ::std::string* release_crm_id();
  inline void set_allocated_crm_id(::std::string* crm_id);

  // optional string application_type = 2;
  inline bool has_application_type() const;
  inline void clear_application_type();
  static const int kApplicationTypeFieldNumber = 2;
  inline const ::std::string& application_type() const;
  inline void set_application_type(const ::std::string& value);
  inline void set_application_type(const char* value);
  inline void set_application_type(const char* value, size_t size);
  inline ::std::string* mutable_application_type();
  inline ::std::string* release_application_type();
  inline void set_allocated_application_type(::std::string* application_type);

  // optional bytes crm_name = 3;
  inline bool has_crm_name() const;
  inline void clear_crm_name();
  static const int kCrmNameFieldNumber = 3;
  inline const ::std::string& crm_name() const;
  inline void set_crm_name(const ::std::string& value);
  inline void set_crm_name(const char* value);
  inline void set_crm_name(const void* value, size_t size);
  inline ::std::string* mutable_crm_name();
  inline ::std::string* release_crm_name();
  inline void set_allocated_crm_name(::std::string* crm_name);

  // @@protoc_insertion_point(class_scope:Crm.CrmIdItem)
 private:
  inline void set_has_crm_id();
  inline void clear_has_crm_id();
  inline void set_has_application_type();
  inline void clear_has_application_type();
  inline void set_has_crm_name();
  inline void clear_has_crm_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* crm_id_;
  ::std::string* application_type_;
  ::std::string* crm_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static CrmIdItem* default_instance_;
};
// -------------------------------------------------------------------

class GetCrmIdListResponse : public ::google::protobuf::Message {
 public:
  GetCrmIdListResponse();
  virtual ~GetCrmIdListResponse();

  GetCrmIdListResponse(const GetCrmIdListResponse& from);

  inline GetCrmIdListResponse& operator=(const GetCrmIdListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCrmIdListResponse& default_instance();

  void Swap(GetCrmIdListResponse* other);

  // implements Message ----------------------------------------------

  GetCrmIdListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCrmIdListResponse& from);
  void MergeFrom(const GetCrmIdListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonResponseFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonResponseFields& common_fields() const;
  inline ::Crm::CommonResponseFields* mutable_common_fields();
  inline ::Crm::CommonResponseFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonResponseFields* common_fields);

  // repeated .Crm.CrmIdItem result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::Crm::CrmIdItem& result(int index) const;
  inline ::Crm::CrmIdItem* mutable_result(int index);
  inline ::Crm::CrmIdItem* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::Crm::CrmIdItem >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::Crm::CrmIdItem >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:Crm.GetCrmIdListResponse)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonResponseFields* common_fields_;
  ::google::protobuf::RepeatedPtrField< ::Crm::CrmIdItem > result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetCrmIdListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetInstListRequest : public ::google::protobuf::Message {
 public:
  GetInstListRequest();
  virtual ~GetInstListRequest();

  GetInstListRequest(const GetInstListRequest& from);

  inline GetInstListRequest& operator=(const GetInstListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInstListRequest& default_instance();

  void Swap(GetInstListRequest* other);

  // implements Message ----------------------------------------------

  GetInstListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetInstListRequest& from);
  void MergeFrom(const GetInstListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonRequestFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonRequestFields& common_fields() const;
  inline ::Crm::CommonRequestFields* mutable_common_fields();
  inline ::Crm::CommonRequestFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonRequestFields* common_fields);

  // @@protoc_insertion_point(class_scope:Crm.GetInstListRequest)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonRequestFields* common_fields_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetInstListRequest* default_instance_;
};
// -------------------------------------------------------------------

class InstitutionItem : public ::google::protobuf::Message {
 public:
  InstitutionItem();
  virtual ~InstitutionItem();

  InstitutionItem(const InstitutionItem& from);

  inline InstitutionItem& operator=(const InstitutionItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstitutionItem& default_instance();

  void Swap(InstitutionItem* other);

  // implements Message ----------------------------------------------

  InstitutionItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstitutionItem& from);
  void MergeFrom(const InstitutionItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string crm_id = 1;
  inline bool has_crm_id() const;
  inline void clear_crm_id();
  static const int kCrmIdFieldNumber = 1;
  inline const ::std::string& crm_id() const;
  inline void set_crm_id(const ::std::string& value);
  inline void set_crm_id(const char* value);
  inline void set_crm_id(const char* value, size_t size);
  inline ::std::string* mutable_crm_id();
  inline ::std::string* release_crm_id();
  inline void set_allocated_crm_id(::std::string* crm_id);

  // optional string inst_id = 2;
  inline bool has_inst_id() const;
  inline void clear_inst_id();
  static const int kInstIdFieldNumber = 2;
  inline const ::std::string& inst_id() const;
  inline void set_inst_id(const ::std::string& value);
  inline void set_inst_id(const char* value);
  inline void set_inst_id(const char* value, size_t size);
  inline ::std::string* mutable_inst_id();
  inline ::std::string* release_inst_id();
  inline void set_allocated_inst_id(::std::string* inst_id);

  // optional string company_id = 3;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 3;
  inline const ::std::string& company_id() const;
  inline void set_company_id(const ::std::string& value);
  inline void set_company_id(const char* value);
  inline void set_company_id(const char* value, size_t size);
  inline ::std::string* mutable_company_id();
  inline ::std::string* release_company_id();
  inline void set_allocated_company_id(::std::string* company_id);

  // optional string qb_id = 4;
  inline bool has_qb_id() const;
  inline void clear_qb_id();
  static const int kQbIdFieldNumber = 4;
  inline const ::std::string& qb_id() const;
  inline void set_qb_id(const ::std::string& value);
  inline void set_qb_id(const char* value);
  inline void set_qb_id(const char* value, size_t size);
  inline ::std::string* mutable_qb_id();
  inline ::std::string* release_qb_id();
  inline void set_allocated_qb_id(::std::string* qb_id);

  // optional string idb_key = 5;
  inline bool has_idb_key() const;
  inline void clear_idb_key();
  static const int kIdbKeyFieldNumber = 5;
  inline const ::std::string& idb_key() const;
  inline void set_idb_key(const ::std::string& value);
  inline void set_idb_key(const char* value);
  inline void set_idb_key(const char* value, size_t size);
  inline ::std::string* mutable_idb_key();
  inline ::std::string* release_idb_key();
  inline void set_allocated_idb_key(::std::string* idb_key);

  // optional bytes inst_short_name_cn = 6;
  inline bool has_inst_short_name_cn() const;
  inline void clear_inst_short_name_cn();
  static const int kInstShortNameCnFieldNumber = 6;
  inline const ::std::string& inst_short_name_cn() const;
  inline void set_inst_short_name_cn(const ::std::string& value);
  inline void set_inst_short_name_cn(const char* value);
  inline void set_inst_short_name_cn(const void* value, size_t size);
  inline ::std::string* mutable_inst_short_name_cn();
  inline ::std::string* release_inst_short_name_cn();
  inline void set_allocated_inst_short_name_cn(::std::string* inst_short_name_cn);

  // optional string pinyin = 7;
  inline bool has_pinyin() const;
  inline void clear_pinyin();
  static const int kPinyinFieldNumber = 7;
  inline const ::std::string& pinyin() const;
  inline void set_pinyin(const ::std::string& value);
  inline void set_pinyin(const char* value);
  inline void set_pinyin(const char* value, size_t size);
  inline ::std::string* mutable_pinyin();
  inline ::std::string* release_pinyin();
  inline void set_allocated_pinyin(::std::string* pinyin);

  // optional string pinyin_full = 8;
  inline bool has_pinyin_full() const;
  inline void clear_pinyin_full();
  static const int kPinyinFullFieldNumber = 8;
  inline const ::std::string& pinyin_full() const;
  inline void set_pinyin_full(const ::std::string& value);
  inline void set_pinyin_full(const char* value);
  inline void set_pinyin_full(const char* value, size_t size);
  inline ::std::string* mutable_pinyin_full();
  inline ::std::string* release_pinyin_full();
  inline void set_allocated_pinyin_full(::std::string* pinyin_full);

  // optional string inst_short_name_en = 9;
  inline bool has_inst_short_name_en() const;
  inline void clear_inst_short_name_en();
  static const int kInstShortNameEnFieldNumber = 9;
  inline const ::std::string& inst_short_name_en() const;
  inline void set_inst_short_name_en(const ::std::string& value);
  inline void set_inst_short_name_en(const char* value);
  inline void set_inst_short_name_en(const char* value, size_t size);
  inline ::std::string* mutable_inst_short_name_en();
  inline ::std::string* release_inst_short_name_en();
  inline void set_allocated_inst_short_name_en(::std::string* inst_short_name_en);

  // optional bytes inst_full_name_cn = 10;
  inline bool has_inst_full_name_cn() const;
  inline void clear_inst_full_name_cn();
  static const int kInstFullNameCnFieldNumber = 10;
  inline const ::std::string& inst_full_name_cn() const;
  inline void set_inst_full_name_cn(const ::std::string& value);
  inline void set_inst_full_name_cn(const char* value);
  inline void set_inst_full_name_cn(const void* value, size_t size);
  inline ::std::string* mutable_inst_full_name_cn();
  inline ::std::string* release_inst_full_name_cn();
  inline void set_allocated_inst_full_name_cn(::std::string* inst_full_name_cn);

  // optional string inst_full_name_en = 11;
  inline bool has_inst_full_name_en() const;
  inline void clear_inst_full_name_en();
  static const int kInstFullNameEnFieldNumber = 11;
  inline const ::std::string& inst_full_name_en() const;
  inline void set_inst_full_name_en(const ::std::string& value);
  inline void set_inst_full_name_en(const char* value);
  inline void set_inst_full_name_en(const char* value, size_t size);
  inline ::std::string* mutable_inst_full_name_en();
  inline ::std::string* release_inst_full_name_en();
  inline void set_allocated_inst_full_name_en(::std::string* inst_full_name_en);

  // optional string inst_code = 12;
  inline bool has_inst_code() const;
  inline void clear_inst_code();
  static const int kInstCodeFieldNumber = 12;
  inline const ::std::string& inst_code() const;
  inline void set_inst_code(const ::std::string& value);
  inline void set_inst_code(const char* value);
  inline void set_inst_code(const char* value, size_t size);
  inline ::std::string* mutable_inst_code();
  inline ::std::string* release_inst_code();
  inline void set_allocated_inst_code(::std::string* inst_code);

  // optional string inst_city_code = 13;
  inline bool has_inst_city_code() const;
  inline void clear_inst_city_code();
  static const int kInstCityCodeFieldNumber = 13;
  inline const ::std::string& inst_city_code() const;
  inline void set_inst_city_code(const ::std::string& value);
  inline void set_inst_city_code(const char* value);
  inline void set_inst_city_code(const char* value, size_t size);
  inline ::std::string* mutable_inst_city_code();
  inline ::std::string* release_inst_city_code();
  inline void set_allocated_inst_city_code(::std::string* inst_city_code);

  // optional bytes inst_city_value = 14;
  inline bool has_inst_city_value() const;
  inline void clear_inst_city_value();
  static const int kInstCityValueFieldNumber = 14;
  inline const ::std::string& inst_city_value() const;
  inline void set_inst_city_value(const ::std::string& value);
  inline void set_inst_city_value(const char* value);
  inline void set_inst_city_value(const void* value, size_t size);
  inline ::std::string* mutable_inst_city_value();
  inline ::std::string* release_inst_city_value();
  inline void set_allocated_inst_city_value(::std::string* inst_city_value);

  // optional bytes desc = 15;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 15;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const void* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string update_time = 16;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 16;
  inline const ::std::string& update_time() const;
  inline void set_update_time(const ::std::string& value);
  inline void set_update_time(const char* value);
  inline void set_update_time(const char* value, size_t size);
  inline ::std::string* mutable_update_time();
  inline ::std::string* release_update_time();
  inline void set_allocated_update_time(::std::string* update_time);

  // optional string inst_type = 17;
  inline bool has_inst_type() const;
  inline void clear_inst_type();
  static const int kInstTypeFieldNumber = 17;
  inline const ::std::string& inst_type() const;
  inline void set_inst_type(const ::std::string& value);
  inline void set_inst_type(const char* value);
  inline void set_inst_type(const char* value, size_t size);
  inline ::std::string* mutable_inst_type();
  inline ::std::string* release_inst_type();
  inline void set_allocated_inst_type(::std::string* inst_type);

  // optional bool is_internal = 18;
  inline bool has_is_internal() const;
  inline void clear_is_internal();
  static const int kIsInternalFieldNumber = 18;
  inline bool is_internal() const;
  inline void set_is_internal(bool value);

  // @@protoc_insertion_point(class_scope:Crm.InstitutionItem)
 private:
  inline void set_has_crm_id();
  inline void clear_has_crm_id();
  inline void set_has_inst_id();
  inline void clear_has_inst_id();
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_qb_id();
  inline void clear_has_qb_id();
  inline void set_has_idb_key();
  inline void clear_has_idb_key();
  inline void set_has_inst_short_name_cn();
  inline void clear_has_inst_short_name_cn();
  inline void set_has_pinyin();
  inline void clear_has_pinyin();
  inline void set_has_pinyin_full();
  inline void clear_has_pinyin_full();
  inline void set_has_inst_short_name_en();
  inline void clear_has_inst_short_name_en();
  inline void set_has_inst_full_name_cn();
  inline void clear_has_inst_full_name_cn();
  inline void set_has_inst_full_name_en();
  inline void clear_has_inst_full_name_en();
  inline void set_has_inst_code();
  inline void clear_has_inst_code();
  inline void set_has_inst_city_code();
  inline void clear_has_inst_city_code();
  inline void set_has_inst_city_value();
  inline void clear_has_inst_city_value();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_update_time();
  inline void clear_has_update_time();
  inline void set_has_inst_type();
  inline void clear_has_inst_type();
  inline void set_has_is_internal();
  inline void clear_has_is_internal();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* crm_id_;
  ::std::string* inst_id_;
  ::std::string* company_id_;
  ::std::string* qb_id_;
  ::std::string* idb_key_;
  ::std::string* inst_short_name_cn_;
  ::std::string* pinyin_;
  ::std::string* pinyin_full_;
  ::std::string* inst_short_name_en_;
  ::std::string* inst_full_name_cn_;
  ::std::string* inst_full_name_en_;
  ::std::string* inst_code_;
  ::std::string* inst_city_code_;
  ::std::string* inst_city_value_;
  ::std::string* desc_;
  ::std::string* update_time_;
  ::std::string* inst_type_;
  bool is_internal_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static InstitutionItem* default_instance_;
};
// -------------------------------------------------------------------

class GetInstListResponse : public ::google::protobuf::Message {
 public:
  GetInstListResponse();
  virtual ~GetInstListResponse();

  GetInstListResponse(const GetInstListResponse& from);

  inline GetInstListResponse& operator=(const GetInstListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetInstListResponse& default_instance();

  void Swap(GetInstListResponse* other);

  // implements Message ----------------------------------------------

  GetInstListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetInstListResponse& from);
  void MergeFrom(const GetInstListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonResponseFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonResponseFields& common_fields() const;
  inline ::Crm::CommonResponseFields* mutable_common_fields();
  inline ::Crm::CommonResponseFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonResponseFields* common_fields);

  // repeated .Crm.InstitutionItem result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::Crm::InstitutionItem& result(int index) const;
  inline ::Crm::InstitutionItem* mutable_result(int index);
  inline ::Crm::InstitutionItem* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::Crm::InstitutionItem >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::Crm::InstitutionItem >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:Crm.GetInstListResponse)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonResponseFields* common_fields_;
  ::google::protobuf::RepeatedPtrField< ::Crm::InstitutionItem > result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetInstListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetCtctListRequest : public ::google::protobuf::Message {
 public:
  GetCtctListRequest();
  virtual ~GetCtctListRequest();

  GetCtctListRequest(const GetCtctListRequest& from);

  inline GetCtctListRequest& operator=(const GetCtctListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCtctListRequest& default_instance();

  void Swap(GetCtctListRequest* other);

  // implements Message ----------------------------------------------

  GetCtctListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCtctListRequest& from);
  void MergeFrom(const GetCtctListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonRequestFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonRequestFields& common_fields() const;
  inline ::Crm::CommonRequestFields* mutable_common_fields();
  inline ::Crm::CommonRequestFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonRequestFields* common_fields);

  // @@protoc_insertion_point(class_scope:Crm.GetCtctListRequest)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonRequestFields* common_fields_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetCtctListRequest* default_instance_;
};
// -------------------------------------------------------------------

class AccountMappingItem : public ::google::protobuf::Message {
 public:
  AccountMappingItem();
  virtual ~AccountMappingItem();

  AccountMappingItem(const AccountMappingItem& from);

  inline AccountMappingItem& operator=(const AccountMappingItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountMappingItem& default_instance();

  void Swap(AccountMappingItem* other);

  // implements Message ----------------------------------------------

  AccountMappingItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountMappingItem& from);
  void MergeFrom(const AccountMappingItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string qb_id = 1;
  inline bool has_qb_id() const;
  inline void clear_qb_id();
  static const int kQbIdFieldNumber = 1;
  inline const ::std::string& qb_id() const;
  inline void set_qb_id(const ::std::string& value);
  inline void set_qb_id(const char* value);
  inline void set_qb_id(const char* value, size_t size);
  inline ::std::string* mutable_qb_id();
  inline ::std::string* release_qb_id();
  inline void set_allocated_qb_id(::std::string* qb_id);

  // optional string idb_key = 2;
  inline bool has_idb_key() const;
  inline void clear_idb_key();
  static const int kIdbKeyFieldNumber = 2;
  inline const ::std::string& idb_key() const;
  inline void set_idb_key(const ::std::string& value);
  inline void set_idb_key(const char* value);
  inline void set_idb_key(const char* value, size_t size);
  inline ::std::string* mutable_idb_key();
  inline ::std::string* release_idb_key();
  inline void set_allocated_idb_key(::std::string* idb_key);

  // optional string account_id = 3;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 3;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  inline void set_allocated_account_id(::std::string* account_id);

  // optional string team_id = 4;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 4;
  inline const ::std::string& team_id() const;
  inline void set_team_id(const ::std::string& value);
  inline void set_team_id(const char* value);
  inline void set_team_id(const char* value, size_t size);
  inline ::std::string* mutable_team_id();
  inline ::std::string* release_team_id();
  inline void set_allocated_team_id(::std::string* team_id);

  // optional string crm_id = 5;
  inline bool has_crm_id() const;
  inline void clear_crm_id();
  static const int kCrmIdFieldNumber = 5;
  inline const ::std::string& crm_id() const;
  inline void set_crm_id(const ::std::string& value);
  inline void set_crm_id(const char* value);
  inline void set_crm_id(const char* value, size_t size);
  inline ::std::string* mutable_crm_id();
  inline ::std::string* release_crm_id();
  inline void set_allocated_crm_id(::std::string* crm_id);

  // optional string ctct_id = 6;
  inline bool has_ctct_id() const;
  inline void clear_ctct_id();
  static const int kCtctIdFieldNumber = 6;
  inline const ::std::string& ctct_id() const;
  inline void set_ctct_id(const ::std::string& value);
  inline void set_ctct_id(const char* value);
  inline void set_ctct_id(const char* value, size_t size);
  inline ::std::string* mutable_ctct_id();
  inline ::std::string* release_ctct_id();
  inline void set_allocated_ctct_id(::std::string* ctct_id);

  // @@protoc_insertion_point(class_scope:Crm.AccountMappingItem)
 private:
  inline void set_has_qb_id();
  inline void clear_has_qb_id();
  inline void set_has_idb_key();
  inline void clear_has_idb_key();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_crm_id();
  inline void clear_has_crm_id();
  inline void set_has_ctct_id();
  inline void clear_has_ctct_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* qb_id_;
  ::std::string* idb_key_;
  ::std::string* account_id_;
  ::std::string* team_id_;
  ::std::string* crm_id_;
  ::std::string* ctct_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static AccountMappingItem* default_instance_;
};
// -------------------------------------------------------------------

class ContactItem : public ::google::protobuf::Message {
 public:
  ContactItem();
  virtual ~ContactItem();

  ContactItem(const ContactItem& from);

  inline ContactItem& operator=(const ContactItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactItem& default_instance();

  void Swap(ContactItem* other);

  // implements Message ----------------------------------------------

  ContactItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContactItem& from);
  void MergeFrom(const ContactItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string crm_id = 1;
  inline bool has_crm_id() const;
  inline void clear_crm_id();
  static const int kCrmIdFieldNumber = 1;
  inline const ::std::string& crm_id() const;
  inline void set_crm_id(const ::std::string& value);
  inline void set_crm_id(const char* value);
  inline void set_crm_id(const char* value, size_t size);
  inline ::std::string* mutable_crm_id();
  inline ::std::string* release_crm_id();
  inline void set_allocated_crm_id(::std::string* crm_id);

  // optional string ctct_id = 2;
  inline bool has_ctct_id() const;
  inline void clear_ctct_id();
  static const int kCtctIdFieldNumber = 2;
  inline const ::std::string& ctct_id() const;
  inline void set_ctct_id(const ::std::string& value);
  inline void set_ctct_id(const char* value);
  inline void set_ctct_id(const char* value, size_t size);
  inline ::std::string* mutable_ctct_id();
  inline ::std::string* release_ctct_id();
  inline void set_allocated_ctct_id(::std::string* ctct_id);

  // optional string company_id = 3;
  inline bool has_company_id() const;
  inline void clear_company_id();
  static const int kCompanyIdFieldNumber = 3;
  inline const ::std::string& company_id() const;
  inline void set_company_id(const ::std::string& value);
  inline void set_company_id(const char* value);
  inline void set_company_id(const char* value, size_t size);
  inline ::std::string* mutable_company_id();
  inline ::std::string* release_company_id();
  inline void set_allocated_company_id(::std::string* company_id);

  // optional string qb_id = 4;
  inline bool has_qb_id() const;
  inline void clear_qb_id();
  static const int kQbIdFieldNumber = 4;
  inline const ::std::string& qb_id() const;
  inline void set_qb_id(const ::std::string& value);
  inline void set_qb_id(const char* value);
  inline void set_qb_id(const char* value, size_t size);
  inline ::std::string* mutable_qb_id();
  inline ::std::string* release_qb_id();
  inline void set_allocated_qb_id(::std::string* qb_id);

  // optional string idb_key = 5;
  inline bool has_idb_key() const;
  inline void clear_idb_key();
  static const int kIdbKeyFieldNumber = 5;
  inline const ::std::string& idb_key() const;
  inline void set_idb_key(const ::std::string& value);
  inline void set_idb_key(const char* value);
  inline void set_idb_key(const char* value, size_t size);
  inline ::std::string* mutable_idb_key();
  inline ::std::string* release_idb_key();
  inline void set_allocated_idb_key(::std::string* idb_key);

  // optional bytes ctct_name = 6;
  inline bool has_ctct_name() const;
  inline void clear_ctct_name();
  static const int kCtctNameFieldNumber = 6;
  inline const ::std::string& ctct_name() const;
  inline void set_ctct_name(const ::std::string& value);
  inline void set_ctct_name(const char* value);
  inline void set_ctct_name(const void* value, size_t size);
  inline ::std::string* mutable_ctct_name();
  inline ::std::string* release_ctct_name();
  inline void set_allocated_ctct_name(::std::string* ctct_name);

  // optional string pinyin = 7;
  inline bool has_pinyin() const;
  inline void clear_pinyin();
  static const int kPinyinFieldNumber = 7;
  inline const ::std::string& pinyin() const;
  inline void set_pinyin(const ::std::string& value);
  inline void set_pinyin(const char* value);
  inline void set_pinyin(const char* value, size_t size);
  inline ::std::string* mutable_pinyin();
  inline ::std::string* release_pinyin();
  inline void set_allocated_pinyin(::std::string* pinyin);

  // optional string pinyin_full = 8;
  inline bool has_pinyin_full() const;
  inline void clear_pinyin_full();
  static const int kPinyinFullFieldNumber = 8;
  inline const ::std::string& pinyin_full() const;
  inline void set_pinyin_full(const ::std::string& value);
  inline void set_pinyin_full(const char* value);
  inline void set_pinyin_full(const char* value, size_t size);
  inline ::std::string* mutable_pinyin_full();
  inline ::std::string* release_pinyin_full();
  inline void set_allocated_pinyin_full(::std::string* pinyin_full);

  // optional string inst_id = 9;
  inline bool has_inst_id() const;
  inline void clear_inst_id();
  static const int kInstIdFieldNumber = 9;
  inline const ::std::string& inst_id() const;
  inline void set_inst_id(const ::std::string& value);
  inline void set_inst_id(const char* value);
  inline void set_inst_id(const char* value, size_t size);
  inline ::std::string* mutable_inst_id();
  inline ::std::string* release_inst_id();
  inline void set_allocated_inst_id(::std::string* inst_id);

  // optional string inst_code = 10;
  inline bool has_inst_code() const;
  inline void clear_inst_code();
  static const int kInstCodeFieldNumber = 10;
  inline const ::std::string& inst_code() const;
  inline void set_inst_code(const ::std::string& value);
  inline void set_inst_code(const char* value);
  inline void set_inst_code(const char* value, size_t size);
  inline ::std::string* mutable_inst_code();
  inline ::std::string* release_inst_code();
  inline void set_allocated_inst_code(::std::string* inst_code);

  // optional string ctct_code = 11;
  inline bool has_ctct_code() const;
  inline void clear_ctct_code();
  static const int kCtctCodeFieldNumber = 11;
  inline const ::std::string& ctct_code() const;
  inline void set_ctct_code(const ::std::string& value);
  inline void set_ctct_code(const char* value);
  inline void set_ctct_code(const char* value, size_t size);
  inline ::std::string* mutable_ctct_code();
  inline ::std::string* release_ctct_code();
  inline void set_allocated_ctct_code(::std::string* ctct_code);

  // optional bool is_vip = 12;
  inline bool has_is_vip() const;
  inline void clear_is_vip();
  static const int kIsVipFieldNumber = 12;
  inline bool is_vip() const;
  inline void set_is_vip(bool value);

  // optional bool is_danger = 13;
  inline bool has_is_danger() const;
  inline void clear_is_danger();
  static const int kIsDangerFieldNumber = 13;
  inline bool is_danger() const;
  inline void set_is_danger(bool value);

  // optional string biz_type = 14;
  inline bool has_biz_type() const;
  inline void clear_biz_type();
  static const int kBizTypeFieldNumber = 14;
  inline const ::std::string& biz_type() const;
  inline void set_biz_type(const ::std::string& value);
  inline void set_biz_type(const char* value);
  inline void set_biz_type(const char* value, size_t size);
  inline ::std::string* mutable_biz_type();
  inline ::std::string* release_biz_type();
  inline void set_allocated_biz_type(::std::string* biz_type);

  // optional string update_time = 15;
  inline bool has_update_time() const;
  inline void clear_update_time();
  static const int kUpdateTimeFieldNumber = 15;
  inline const ::std::string& update_time() const;
  inline void set_update_time(const ::std::string& value);
  inline void set_update_time(const char* value);
  inline void set_update_time(const char* value, size_t size);
  inline ::std::string* mutable_update_time();
  inline ::std::string* release_update_time();
  inline void set_allocated_update_time(::std::string* update_time);

  // repeated .Crm.AccountMappingItem account_mapping = 16;
  inline int account_mapping_size() const;
  inline void clear_account_mapping();
  static const int kAccountMappingFieldNumber = 16;
  inline const ::Crm::AccountMappingItem& account_mapping(int index) const;
  inline ::Crm::AccountMappingItem* mutable_account_mapping(int index);
  inline ::Crm::AccountMappingItem* add_account_mapping();
  inline const ::google::protobuf::RepeatedPtrField< ::Crm::AccountMappingItem >&
      account_mapping() const;
  inline ::google::protobuf::RepeatedPtrField< ::Crm::AccountMappingItem >*
      mutable_account_mapping();

  // @@protoc_insertion_point(class_scope:Crm.ContactItem)
 private:
  inline void set_has_crm_id();
  inline void clear_has_crm_id();
  inline void set_has_ctct_id();
  inline void clear_has_ctct_id();
  inline void set_has_company_id();
  inline void clear_has_company_id();
  inline void set_has_qb_id();
  inline void clear_has_qb_id();
  inline void set_has_idb_key();
  inline void clear_has_idb_key();
  inline void set_has_ctct_name();
  inline void clear_has_ctct_name();
  inline void set_has_pinyin();
  inline void clear_has_pinyin();
  inline void set_has_pinyin_full();
  inline void clear_has_pinyin_full();
  inline void set_has_inst_id();
  inline void clear_has_inst_id();
  inline void set_has_inst_code();
  inline void clear_has_inst_code();
  inline void set_has_ctct_code();
  inline void clear_has_ctct_code();
  inline void set_has_is_vip();
  inline void clear_has_is_vip();
  inline void set_has_is_danger();
  inline void clear_has_is_danger();
  inline void set_has_biz_type();
  inline void clear_has_biz_type();
  inline void set_has_update_time();
  inline void clear_has_update_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* crm_id_;
  ::std::string* ctct_id_;
  ::std::string* company_id_;
  ::std::string* qb_id_;
  ::std::string* idb_key_;
  ::std::string* ctct_name_;
  ::std::string* pinyin_;
  ::std::string* pinyin_full_;
  ::std::string* inst_id_;
  ::std::string* inst_code_;
  ::std::string* ctct_code_;
  ::std::string* biz_type_;
  ::std::string* update_time_;
  ::google::protobuf::RepeatedPtrField< ::Crm::AccountMappingItem > account_mapping_;
  bool is_vip_;
  bool is_danger_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static ContactItem* default_instance_;
};
// -------------------------------------------------------------------

class GetCtctListResponse : public ::google::protobuf::Message {
 public:
  GetCtctListResponse();
  virtual ~GetCtctListResponse();

  GetCtctListResponse(const GetCtctListResponse& from);

  inline GetCtctListResponse& operator=(const GetCtctListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetCtctListResponse& default_instance();

  void Swap(GetCtctListResponse* other);

  // implements Message ----------------------------------------------

  GetCtctListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetCtctListResponse& from);
  void MergeFrom(const GetCtctListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonResponseFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonResponseFields& common_fields() const;
  inline ::Crm::CommonResponseFields* mutable_common_fields();
  inline ::Crm::CommonResponseFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonResponseFields* common_fields);

  // repeated .Crm.ContactItem result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::Crm::ContactItem& result(int index) const;
  inline ::Crm::ContactItem* mutable_result(int index);
  inline ::Crm::ContactItem* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::Crm::ContactItem >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::Crm::ContactItem >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:Crm.GetCtctListResponse)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonResponseFields* common_fields_;
  ::google::protobuf::RepeatedPtrField< ::Crm::ContactItem > result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetCtctListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetAccountListRequest : public ::google::protobuf::Message {
 public:
  GetAccountListRequest();
  virtual ~GetAccountListRequest();

  GetAccountListRequest(const GetAccountListRequest& from);

  inline GetAccountListRequest& operator=(const GetAccountListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAccountListRequest& default_instance();

  void Swap(GetAccountListRequest* other);

  // implements Message ----------------------------------------------

  GetAccountListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAccountListRequest& from);
  void MergeFrom(const GetAccountListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonRequestFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonRequestFields& common_fields() const;
  inline ::Crm::CommonRequestFields* mutable_common_fields();
  inline ::Crm::CommonRequestFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonRequestFields* common_fields);

  // @@protoc_insertion_point(class_scope:Crm.GetAccountListRequest)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonRequestFields* common_fields_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetAccountListRequest* default_instance_;
};
// -------------------------------------------------------------------

class AccountItem : public ::google::protobuf::Message {
 public:
  AccountItem();
  virtual ~AccountItem();

  AccountItem(const AccountItem& from);

  inline AccountItem& operator=(const AccountItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountItem& default_instance();

  void Swap(AccountItem* other);

  // implements Message ----------------------------------------------

  AccountItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountItem& from);
  void MergeFrom(const AccountItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string crm_id = 1;
  inline bool has_crm_id() const;
  inline void clear_crm_id();
  static const int kCrmIdFieldNumber = 1;
  inline const ::std::string& crm_id() const;
  inline void set_crm_id(const ::std::string& value);
  inline void set_crm_id(const char* value);
  inline void set_crm_id(const char* value, size_t size);
  inline ::std::string* mutable_crm_id();
  inline ::std::string* release_crm_id();
  inline void set_allocated_crm_id(::std::string* crm_id);

  // optional string account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline const ::std::string& account_id() const;
  inline void set_account_id(const ::std::string& value);
  inline void set_account_id(const char* value);
  inline void set_account_id(const char* value, size_t size);
  inline ::std::string* mutable_account_id();
  inline ::std::string* release_account_id();
  inline void set_allocated_account_id(::std::string* account_id);

  // optional string idb_key = 3;
  inline bool has_idb_key() const;
  inline void clear_idb_key();
  static const int kIdbKeyFieldNumber = 3;
  inline const ::std::string& idb_key() const;
  inline void set_idb_key(const ::std::string& value);
  inline void set_idb_key(const char* value);
  inline void set_idb_key(const char* value, size_t size);
  inline ::std::string* mutable_idb_key();
  inline ::std::string* release_idb_key();
  inline void set_allocated_idb_key(::std::string* idb_key);

  // optional string account = 4;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string account_name = 5;
  inline bool has_account_name() const;
  inline void clear_account_name();
  static const int kAccountNameFieldNumber = 5;
  inline const ::std::string& account_name() const;
  inline void set_account_name(const ::std::string& value);
  inline void set_account_name(const char* value);
  inline void set_account_name(const char* value, size_t size);
  inline ::std::string* mutable_account_name();
  inline ::std::string* release_account_name();
  inline void set_allocated_account_name(::std::string* account_name);

  // optional string serial_number = 6;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 6;
  inline const ::std::string& serial_number() const;
  inline void set_serial_number(const ::std::string& value);
  inline void set_serial_number(const char* value);
  inline void set_serial_number(const char* value, size_t size);
  inline ::std::string* mutable_serial_number();
  inline ::std::string* release_serial_number();
  inline void set_allocated_serial_number(::std::string* serial_number);

  // optional string role_code = 7;
  inline bool has_role_code() const;
  inline void clear_role_code();
  static const int kRoleCodeFieldNumber = 7;
  inline const ::std::string& role_code() const;
  inline void set_role_code(const ::std::string& value);
  inline void set_role_code(const char* value);
  inline void set_role_code(const char* value, size_t size);
  inline ::std::string* mutable_role_code();
  inline ::std::string* release_role_code();
  inline void set_allocated_role_code(::std::string* role_code);

  // repeated string team_ids = 8;
  inline int team_ids_size() const;
  inline void clear_team_ids();
  static const int kTeamIdsFieldNumber = 8;
  inline const ::std::string& team_ids(int index) const;
  inline ::std::string* mutable_team_ids(int index);
  inline void set_team_ids(int index, const ::std::string& value);
  inline void set_team_ids(int index, const char* value);
  inline void set_team_ids(int index, const char* value, size_t size);
  inline ::std::string* add_team_ids();
  inline void add_team_ids(const ::std::string& value);
  inline void add_team_ids(const char* value);
  inline void add_team_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& team_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_team_ids();

  // @@protoc_insertion_point(class_scope:Crm.AccountItem)
 private:
  inline void set_has_crm_id();
  inline void clear_has_crm_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_idb_key();
  inline void clear_has_idb_key();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_account_name();
  inline void clear_has_account_name();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_role_code();
  inline void clear_has_role_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* crm_id_;
  ::std::string* account_id_;
  ::std::string* idb_key_;
  ::std::string* account_;
  ::std::string* account_name_;
  ::std::string* serial_number_;
  ::std::string* role_code_;
  ::google::protobuf::RepeatedPtrField< ::std::string> team_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static AccountItem* default_instance_;
};
// -------------------------------------------------------------------

class GetAccountListResponse : public ::google::protobuf::Message {
 public:
  GetAccountListResponse();
  virtual ~GetAccountListResponse();

  GetAccountListResponse(const GetAccountListResponse& from);

  inline GetAccountListResponse& operator=(const GetAccountListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetAccountListResponse& default_instance();

  void Swap(GetAccountListResponse* other);

  // implements Message ----------------------------------------------

  GetAccountListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetAccountListResponse& from);
  void MergeFrom(const GetAccountListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonResponseFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonResponseFields& common_fields() const;
  inline ::Crm::CommonResponseFields* mutable_common_fields();
  inline ::Crm::CommonResponseFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonResponseFields* common_fields);

  // repeated .Crm.AccountItem result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::Crm::AccountItem& result(int index) const;
  inline ::Crm::AccountItem* mutable_result(int index);
  inline ::Crm::AccountItem* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::Crm::AccountItem >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::Crm::AccountItem >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:Crm.GetAccountListResponse)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonResponseFields* common_fields_;
  ::google::protobuf::RepeatedPtrField< ::Crm::AccountItem > result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetAccountListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetRoleListRequest : public ::google::protobuf::Message {
 public:
  GetRoleListRequest();
  virtual ~GetRoleListRequest();

  GetRoleListRequest(const GetRoleListRequest& from);

  inline GetRoleListRequest& operator=(const GetRoleListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoleListRequest& default_instance();

  void Swap(GetRoleListRequest* other);

  // implements Message ----------------------------------------------

  GetRoleListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRoleListRequest& from);
  void MergeFrom(const GetRoleListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonRequestFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonRequestFields& common_fields() const;
  inline ::Crm::CommonRequestFields* mutable_common_fields();
  inline ::Crm::CommonRequestFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonRequestFields* common_fields);

  // @@protoc_insertion_point(class_scope:Crm.GetRoleListRequest)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonRequestFields* common_fields_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetRoleListRequest* default_instance_;
};
// -------------------------------------------------------------------

class RoleItem : public ::google::protobuf::Message {
 public:
  RoleItem();
  virtual ~RoleItem();

  RoleItem(const RoleItem& from);

  inline RoleItem& operator=(const RoleItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleItem& default_instance();

  void Swap(RoleItem* other);

  // implements Message ----------------------------------------------

  RoleItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoleItem& from);
  void MergeFrom(const RoleItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string crm_id = 1;
  inline bool has_crm_id() const;
  inline void clear_crm_id();
  static const int kCrmIdFieldNumber = 1;
  inline const ::std::string& crm_id() const;
  inline void set_crm_id(const ::std::string& value);
  inline void set_crm_id(const char* value);
  inline void set_crm_id(const char* value, size_t size);
  inline ::std::string* mutable_crm_id();
  inline ::std::string* release_crm_id();
  inline void set_allocated_crm_id(::std::string* crm_id);

  // optional string role_code = 2;
  inline bool has_role_code() const;
  inline void clear_role_code();
  static const int kRoleCodeFieldNumber = 2;
  inline const ::std::string& role_code() const;
  inline void set_role_code(const ::std::string& value);
  inline void set_role_code(const char* value);
  inline void set_role_code(const char* value, size_t size);
  inline ::std::string* mutable_role_code();
  inline ::std::string* release_role_code();
  inline void set_allocated_role_code(::std::string* role_code);

  // optional string role_name = 3;
  inline bool has_role_name() const;
  inline void clear_role_name();
  static const int kRoleNameFieldNumber = 3;
  inline const ::std::string& role_name() const;
  inline void set_role_name(const ::std::string& value);
  inline void set_role_name(const char* value);
  inline void set_role_name(const char* value, size_t size);
  inline ::std::string* mutable_role_name();
  inline ::std::string* release_role_name();
  inline void set_allocated_role_name(::std::string* role_name);

  // @@protoc_insertion_point(class_scope:Crm.RoleItem)
 private:
  inline void set_has_crm_id();
  inline void clear_has_crm_id();
  inline void set_has_role_code();
  inline void clear_has_role_code();
  inline void set_has_role_name();
  inline void clear_has_role_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* crm_id_;
  ::std::string* role_code_;
  ::std::string* role_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static RoleItem* default_instance_;
};
// -------------------------------------------------------------------

class GetRoleListResponse : public ::google::protobuf::Message {
 public:
  GetRoleListResponse();
  virtual ~GetRoleListResponse();

  GetRoleListResponse(const GetRoleListResponse& from);

  inline GetRoleListResponse& operator=(const GetRoleListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRoleListResponse& default_instance();

  void Swap(GetRoleListResponse* other);

  // implements Message ----------------------------------------------

  GetRoleListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetRoleListResponse& from);
  void MergeFrom(const GetRoleListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonResponseFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonResponseFields& common_fields() const;
  inline ::Crm::CommonResponseFields* mutable_common_fields();
  inline ::Crm::CommonResponseFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonResponseFields* common_fields);

  // repeated .Crm.RoleItem result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::Crm::RoleItem& result(int index) const;
  inline ::Crm::RoleItem* mutable_result(int index);
  inline ::Crm::RoleItem* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::Crm::RoleItem >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::Crm::RoleItem >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:Crm.GetRoleListResponse)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonResponseFields* common_fields_;
  ::google::protobuf::RepeatedPtrField< ::Crm::RoleItem > result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetRoleListResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetTeamListRequest : public ::google::protobuf::Message {
 public:
  GetTeamListRequest();
  virtual ~GetTeamListRequest();

  GetTeamListRequest(const GetTeamListRequest& from);

  inline GetTeamListRequest& operator=(const GetTeamListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTeamListRequest& default_instance();

  void Swap(GetTeamListRequest* other);

  // implements Message ----------------------------------------------

  GetTeamListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTeamListRequest& from);
  void MergeFrom(const GetTeamListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonRequestFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonRequestFields& common_fields() const;
  inline ::Crm::CommonRequestFields* mutable_common_fields();
  inline ::Crm::CommonRequestFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonRequestFields* common_fields);

  // @@protoc_insertion_point(class_scope:Crm.GetTeamListRequest)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonRequestFields* common_fields_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetTeamListRequest* default_instance_;
};
// -------------------------------------------------------------------

class TeamItem : public ::google::protobuf::Message {
 public:
  TeamItem();
  virtual ~TeamItem();

  TeamItem(const TeamItem& from);

  inline TeamItem& operator=(const TeamItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamItem& default_instance();

  void Swap(TeamItem* other);

  // implements Message ----------------------------------------------

  TeamItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamItem& from);
  void MergeFrom(const TeamItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string crm_id = 1;
  inline bool has_crm_id() const;
  inline void clear_crm_id();
  static const int kCrmIdFieldNumber = 1;
  inline const ::std::string& crm_id() const;
  inline void set_crm_id(const ::std::string& value);
  inline void set_crm_id(const char* value);
  inline void set_crm_id(const char* value, size_t size);
  inline ::std::string* mutable_crm_id();
  inline ::std::string* release_crm_id();
  inline void set_allocated_crm_id(::std::string* crm_id);

  // optional string team_id = 2;
  inline bool has_team_id() const;
  inline void clear_team_id();
  static const int kTeamIdFieldNumber = 2;
  inline const ::std::string& team_id() const;
  inline void set_team_id(const ::std::string& value);
  inline void set_team_id(const char* value);
  inline void set_team_id(const char* value, size_t size);
  inline ::std::string* mutable_team_id();
  inline ::std::string* release_team_id();
  inline void set_allocated_team_id(::std::string* team_id);

  // optional bytes team_name = 3;
  inline bool has_team_name() const;
  inline void clear_team_name();
  static const int kTeamNameFieldNumber = 3;
  inline const ::std::string& team_name() const;
  inline void set_team_name(const ::std::string& value);
  inline void set_team_name(const char* value);
  inline void set_team_name(const void* value, size_t size);
  inline ::std::string* mutable_team_name();
  inline ::std::string* release_team_name();
  inline void set_allocated_team_name(::std::string* team_name);

  // optional bytes team_code = 4;
  inline bool has_team_code() const;
  inline void clear_team_code();
  static const int kTeamCodeFieldNumber = 4;
  inline const ::std::string& team_code() const;
  inline void set_team_code(const ::std::string& value);
  inline void set_team_code(const char* value);
  inline void set_team_code(const void* value, size_t size);
  inline ::std::string* mutable_team_code();
  inline ::std::string* release_team_code();
  inline void set_allocated_team_code(::std::string* team_code);

  // optional bytes desc = 5;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 5;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const void* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:Crm.TeamItem)
 private:
  inline void set_has_crm_id();
  inline void clear_has_crm_id();
  inline void set_has_team_id();
  inline void clear_has_team_id();
  inline void set_has_team_name();
  inline void clear_has_team_name();
  inline void set_has_team_code();
  inline void clear_has_team_code();
  inline void set_has_desc();
  inline void clear_has_desc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* crm_id_;
  ::std::string* team_id_;
  ::std::string* team_name_;
  ::std::string* team_code_;
  ::std::string* desc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static TeamItem* default_instance_;
};
// -------------------------------------------------------------------

class GetTeamListResponse : public ::google::protobuf::Message {
 public:
  GetTeamListResponse();
  virtual ~GetTeamListResponse();

  GetTeamListResponse(const GetTeamListResponse& from);

  inline GetTeamListResponse& operator=(const GetTeamListResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTeamListResponse& default_instance();

  void Swap(GetTeamListResponse* other);

  // implements Message ----------------------------------------------

  GetTeamListResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetTeamListResponse& from);
  void MergeFrom(const GetTeamListResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Crm.CommonResponseFields common_fields = 1;
  inline bool has_common_fields() const;
  inline void clear_common_fields();
  static const int kCommonFieldsFieldNumber = 1;
  inline const ::Crm::CommonResponseFields& common_fields() const;
  inline ::Crm::CommonResponseFields* mutable_common_fields();
  inline ::Crm::CommonResponseFields* release_common_fields();
  inline void set_allocated_common_fields(::Crm::CommonResponseFields* common_fields);

  // repeated .Crm.TeamItem result = 2;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline const ::Crm::TeamItem& result(int index) const;
  inline ::Crm::TeamItem* mutable_result(int index);
  inline ::Crm::TeamItem* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::Crm::TeamItem >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::Crm::TeamItem >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:Crm.GetTeamListResponse)
 private:
  inline void set_has_common_fields();
  inline void clear_has_common_fields();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Crm::CommonResponseFields* common_fields_;
  ::google::protobuf::RepeatedPtrField< ::Crm::TeamItem > result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static GetTeamListResponse* default_instance_;
};
// -------------------------------------------------------------------

class AccountUpdateEvent : public ::google::protobuf::Message {
 public:
  AccountUpdateEvent();
  virtual ~AccountUpdateEvent();

  AccountUpdateEvent(const AccountUpdateEvent& from);

  inline AccountUpdateEvent& operator=(const AccountUpdateEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountUpdateEvent& default_instance();

  void Swap(AccountUpdateEvent* other);

  // implements Message ----------------------------------------------

  AccountUpdateEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountUpdateEvent& from);
  void MergeFrom(const AccountUpdateEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string eventType = 1;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 1;
  inline const ::std::string& eventtype() const;
  inline void set_eventtype(const ::std::string& value);
  inline void set_eventtype(const char* value);
  inline void set_eventtype(const char* value, size_t size);
  inline ::std::string* mutable_eventtype();
  inline ::std::string* release_eventtype();
  inline void set_allocated_eventtype(::std::string* eventtype);

  // optional .Crm.AccountItem account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::Crm::AccountItem& account() const;
  inline ::Crm::AccountItem* mutable_account();
  inline ::Crm::AccountItem* release_account();
  inline void set_allocated_account(::Crm::AccountItem* account);

  // @@protoc_insertion_point(class_scope:Crm.AccountUpdateEvent)
 private:
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_account();
  inline void clear_has_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* eventtype_;
  ::Crm::AccountItem* account_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static AccountUpdateEvent* default_instance_;
};
// -------------------------------------------------------------------

class TeamUpdateEvent : public ::google::protobuf::Message {
 public:
  TeamUpdateEvent();
  virtual ~TeamUpdateEvent();

  TeamUpdateEvent(const TeamUpdateEvent& from);

  inline TeamUpdateEvent& operator=(const TeamUpdateEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamUpdateEvent& default_instance();

  void Swap(TeamUpdateEvent* other);

  // implements Message ----------------------------------------------

  TeamUpdateEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamUpdateEvent& from);
  void MergeFrom(const TeamUpdateEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string eventType = 1;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 1;
  inline const ::std::string& eventtype() const;
  inline void set_eventtype(const ::std::string& value);
  inline void set_eventtype(const char* value);
  inline void set_eventtype(const char* value, size_t size);
  inline ::std::string* mutable_eventtype();
  inline ::std::string* release_eventtype();
  inline void set_allocated_eventtype(::std::string* eventtype);

  // optional .Crm.TeamItem team = 2;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 2;
  inline const ::Crm::TeamItem& team() const;
  inline ::Crm::TeamItem* mutable_team();
  inline ::Crm::TeamItem* release_team();
  inline void set_allocated_team(::Crm::TeamItem* team);

  // @@protoc_insertion_point(class_scope:Crm.TeamUpdateEvent)
 private:
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_team();
  inline void clear_has_team();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* eventtype_;
  ::Crm::TeamItem* team_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static TeamUpdateEvent* default_instance_;
};
// -------------------------------------------------------------------

class InstitutionUpdateEvent : public ::google::protobuf::Message {
 public:
  InstitutionUpdateEvent();
  virtual ~InstitutionUpdateEvent();

  InstitutionUpdateEvent(const InstitutionUpdateEvent& from);

  inline InstitutionUpdateEvent& operator=(const InstitutionUpdateEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstitutionUpdateEvent& default_instance();

  void Swap(InstitutionUpdateEvent* other);

  // implements Message ----------------------------------------------

  InstitutionUpdateEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstitutionUpdateEvent& from);
  void MergeFrom(const InstitutionUpdateEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string eventType = 1;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 1;
  inline const ::std::string& eventtype() const;
  inline void set_eventtype(const ::std::string& value);
  inline void set_eventtype(const char* value);
  inline void set_eventtype(const char* value, size_t size);
  inline ::std::string* mutable_eventtype();
  inline ::std::string* release_eventtype();
  inline void set_allocated_eventtype(::std::string* eventtype);

  // optional .Crm.InstitutionItem institution = 2;
  inline bool has_institution() const;
  inline void clear_institution();
  static const int kInstitutionFieldNumber = 2;
  inline const ::Crm::InstitutionItem& institution() const;
  inline ::Crm::InstitutionItem* mutable_institution();
  inline ::Crm::InstitutionItem* release_institution();
  inline void set_allocated_institution(::Crm::InstitutionItem* institution);

  // @@protoc_insertion_point(class_scope:Crm.InstitutionUpdateEvent)
 private:
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_institution();
  inline void clear_has_institution();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* eventtype_;
  ::Crm::InstitutionItem* institution_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static InstitutionUpdateEvent* default_instance_;
};
// -------------------------------------------------------------------

class ContactUpdateEvent : public ::google::protobuf::Message {
 public:
  ContactUpdateEvent();
  virtual ~ContactUpdateEvent();

  ContactUpdateEvent(const ContactUpdateEvent& from);

  inline ContactUpdateEvent& operator=(const ContactUpdateEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactUpdateEvent& default_instance();

  void Swap(ContactUpdateEvent* other);

  // implements Message ----------------------------------------------

  ContactUpdateEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContactUpdateEvent& from);
  void MergeFrom(const ContactUpdateEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string eventType = 1;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 1;
  inline const ::std::string& eventtype() const;
  inline void set_eventtype(const ::std::string& value);
  inline void set_eventtype(const char* value);
  inline void set_eventtype(const char* value, size_t size);
  inline ::std::string* mutable_eventtype();
  inline ::std::string* release_eventtype();
  inline void set_allocated_eventtype(::std::string* eventtype);

  // optional .Crm.ContactItem contact = 2;
  inline bool has_contact() const;
  inline void clear_contact();
  static const int kContactFieldNumber = 2;
  inline const ::Crm::ContactItem& contact() const;
  inline ::Crm::ContactItem* mutable_contact();
  inline ::Crm::ContactItem* release_contact();
  inline void set_allocated_contact(::Crm::ContactItem* contact);

  // @@protoc_insertion_point(class_scope:Crm.ContactUpdateEvent)
 private:
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_contact();
  inline void clear_has_contact();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* eventtype_;
  ::Crm::ContactItem* contact_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static ContactUpdateEvent* default_instance_;
};
// -------------------------------------------------------------------

class ManagerUpdateEvent : public ::google::protobuf::Message {
 public:
  ManagerUpdateEvent();
  virtual ~ManagerUpdateEvent();

  ManagerUpdateEvent(const ManagerUpdateEvent& from);

  inline ManagerUpdateEvent& operator=(const ManagerUpdateEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManagerUpdateEvent& default_instance();

  void Swap(ManagerUpdateEvent* other);

  // implements Message ----------------------------------------------

  ManagerUpdateEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManagerUpdateEvent& from);
  void MergeFrom(const ManagerUpdateEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string eventType = 1;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 1;
  inline const ::std::string& eventtype() const;
  inline void set_eventtype(const ::std::string& value);
  inline void set_eventtype(const char* value);
  inline void set_eventtype(const char* value, size_t size);
  inline ::std::string* mutable_eventtype();
  inline ::std::string* release_eventtype();
  inline void set_allocated_eventtype(::std::string* eventtype);

  // repeated .Crm.AccountMappingItem mappings = 2;
  inline int mappings_size() const;
  inline void clear_mappings();
  static const int kMappingsFieldNumber = 2;
  inline const ::Crm::AccountMappingItem& mappings(int index) const;
  inline ::Crm::AccountMappingItem* mutable_mappings(int index);
  inline ::Crm::AccountMappingItem* add_mappings();
  inline const ::google::protobuf::RepeatedPtrField< ::Crm::AccountMappingItem >&
      mappings() const;
  inline ::google::protobuf::RepeatedPtrField< ::Crm::AccountMappingItem >*
      mutable_mappings();

  // @@protoc_insertion_point(class_scope:Crm.ManagerUpdateEvent)
 private:
  inline void set_has_eventtype();
  inline void clear_has_eventtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* eventtype_;
  ::google::protobuf::RepeatedPtrField< ::Crm::AccountMappingItem > mappings_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_CrmProto_2eproto();
  friend void protobuf_AssignDesc_CrmProto_2eproto();
  friend void protobuf_ShutdownFile_CrmProto_2eproto();

  void InitAsDefaultInstance();
  static ManagerUpdateEvent* default_instance_;
};
// ===================================================================


// ===================================================================

// CommonRequestFields

// optional string request_id = 1;
inline bool CommonRequestFields::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonRequestFields::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonRequestFields::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonRequestFields::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& CommonRequestFields::request_id() const {
  return *request_id_;
}
inline void CommonRequestFields::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void CommonRequestFields::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void CommonRequestFields::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonRequestFields::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* CommonRequestFields::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonRequestFields::set_allocated_request_id(::std::string* request_id) {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    delete request_id_;
  }
  if (request_id) {
    set_has_request_id();
    request_id_ = request_id;
  } else {
    clear_has_request_id();
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes username = 2;
inline bool CommonRequestFields::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonRequestFields::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonRequestFields::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonRequestFields::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& CommonRequestFields::username() const {
  return *username_;
}
inline void CommonRequestFields::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void CommonRequestFields::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void CommonRequestFields::set_username(const void* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonRequestFields::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* CommonRequestFields::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonRequestFields::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 3;
inline bool CommonRequestFields::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonRequestFields::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonRequestFields::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonRequestFields::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CommonRequestFields::password() const {
  return *password_;
}
inline void CommonRequestFields::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CommonRequestFields::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CommonRequestFields::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonRequestFields::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CommonRequestFields::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonRequestFields::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string currentAccountId = 4;
inline bool CommonRequestFields::has_currentaccountid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonRequestFields::set_has_currentaccountid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonRequestFields::clear_has_currentaccountid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonRequestFields::clear_currentaccountid() {
  if (currentaccountid_ != &::google::protobuf::internal::kEmptyString) {
    currentaccountid_->clear();
  }
  clear_has_currentaccountid();
}
inline const ::std::string& CommonRequestFields::currentaccountid() const {
  return *currentaccountid_;
}
inline void CommonRequestFields::set_currentaccountid(const ::std::string& value) {
  set_has_currentaccountid();
  if (currentaccountid_ == &::google::protobuf::internal::kEmptyString) {
    currentaccountid_ = new ::std::string;
  }
  currentaccountid_->assign(value);
}
inline void CommonRequestFields::set_currentaccountid(const char* value) {
  set_has_currentaccountid();
  if (currentaccountid_ == &::google::protobuf::internal::kEmptyString) {
    currentaccountid_ = new ::std::string;
  }
  currentaccountid_->assign(value);
}
inline void CommonRequestFields::set_currentaccountid(const char* value, size_t size) {
  set_has_currentaccountid();
  if (currentaccountid_ == &::google::protobuf::internal::kEmptyString) {
    currentaccountid_ = new ::std::string;
  }
  currentaccountid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonRequestFields::mutable_currentaccountid() {
  set_has_currentaccountid();
  if (currentaccountid_ == &::google::protobuf::internal::kEmptyString) {
    currentaccountid_ = new ::std::string;
  }
  return currentaccountid_;
}
inline ::std::string* CommonRequestFields::release_currentaccountid() {
  clear_has_currentaccountid();
  if (currentaccountid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currentaccountid_;
    currentaccountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonRequestFields::set_allocated_currentaccountid(::std::string* currentaccountid) {
  if (currentaccountid_ != &::google::protobuf::internal::kEmptyString) {
    delete currentaccountid_;
  }
  if (currentaccountid) {
    set_has_currentaccountid();
    currentaccountid_ = currentaccountid;
  } else {
    clear_has_currentaccountid();
    currentaccountid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 crm_id = 5;
inline bool CommonRequestFields::has_crm_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonRequestFields::set_has_crm_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonRequestFields::clear_has_crm_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonRequestFields::clear_crm_id() {
  crm_id_ = GOOGLE_LONGLONG(0);
  clear_has_crm_id();
}
inline ::google::protobuf::int64 CommonRequestFields::crm_id() const {
  return crm_id_;
}
inline void CommonRequestFields::set_crm_id(::google::protobuf::int64 value) {
  set_has_crm_id();
  crm_id_ = value;
}

// optional string application_type = 6;
inline bool CommonRequestFields::has_application_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonRequestFields::set_has_application_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonRequestFields::clear_has_application_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonRequestFields::clear_application_type() {
  if (application_type_ != &::google::protobuf::internal::kEmptyString) {
    application_type_->clear();
  }
  clear_has_application_type();
}
inline const ::std::string& CommonRequestFields::application_type() const {
  return *application_type_;
}
inline void CommonRequestFields::set_application_type(const ::std::string& value) {
  set_has_application_type();
  if (application_type_ == &::google::protobuf::internal::kEmptyString) {
    application_type_ = new ::std::string;
  }
  application_type_->assign(value);
}
inline void CommonRequestFields::set_application_type(const char* value) {
  set_has_application_type();
  if (application_type_ == &::google::protobuf::internal::kEmptyString) {
    application_type_ = new ::std::string;
  }
  application_type_->assign(value);
}
inline void CommonRequestFields::set_application_type(const char* value, size_t size) {
  set_has_application_type();
  if (application_type_ == &::google::protobuf::internal::kEmptyString) {
    application_type_ = new ::std::string;
  }
  application_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonRequestFields::mutable_application_type() {
  set_has_application_type();
  if (application_type_ == &::google::protobuf::internal::kEmptyString) {
    application_type_ = new ::std::string;
  }
  return application_type_;
}
inline ::std::string* CommonRequestFields::release_application_type() {
  clear_has_application_type();
  if (application_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = application_type_;
    application_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonRequestFields::set_allocated_application_type(::std::string* application_type) {
  if (application_type_ != &::google::protobuf::internal::kEmptyString) {
    delete application_type_;
  }
  if (application_type) {
    set_has_application_type();
    application_type_ = application_type;
  } else {
    clear_has_application_type();
    application_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 page_size = 7 [default = 100];
inline bool CommonRequestFields::has_page_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommonRequestFields::set_has_page_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommonRequestFields::clear_has_page_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommonRequestFields::clear_page_size() {
  page_size_ = 100;
  clear_has_page_size();
}
inline ::google::protobuf::int32 CommonRequestFields::page_size() const {
  return page_size_;
}
inline void CommonRequestFields::set_page_size(::google::protobuf::int32 value) {
  set_has_page_size();
  page_size_ = value;
}

// optional int32 page_number = 8 [default = 0];
inline bool CommonRequestFields::has_page_number() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommonRequestFields::set_has_page_number() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommonRequestFields::clear_has_page_number() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommonRequestFields::clear_page_number() {
  page_number_ = 0;
  clear_has_page_number();
}
inline ::google::protobuf::int32 CommonRequestFields::page_number() const {
  return page_number_;
}
inline void CommonRequestFields::set_page_number(::google::protobuf::int32 value) {
  set_has_page_number();
  page_number_ = value;
}

// -------------------------------------------------------------------

// CommonResponseFields

// optional string request_id = 1;
inline bool CommonResponseFields::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommonResponseFields::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommonResponseFields::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommonResponseFields::clear_request_id() {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    request_id_->clear();
  }
  clear_has_request_id();
}
inline const ::std::string& CommonResponseFields::request_id() const {
  return *request_id_;
}
inline void CommonResponseFields::set_request_id(const ::std::string& value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void CommonResponseFields::set_request_id(const char* value) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(value);
}
inline void CommonResponseFields::set_request_id(const char* value, size_t size) {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  request_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonResponseFields::mutable_request_id() {
  set_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    request_id_ = new ::std::string;
  }
  return request_id_;
}
inline ::std::string* CommonResponseFields::release_request_id() {
  clear_has_request_id();
  if (request_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = request_id_;
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonResponseFields::set_allocated_request_id(::std::string* request_id) {
  if (request_id_ != &::google::protobuf::internal::kEmptyString) {
    delete request_id_;
  }
  if (request_id) {
    set_has_request_id();
    request_id_ = request_id;
  } else {
    clear_has_request_id();
    request_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string return_code = 2;
inline bool CommonResponseFields::has_return_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommonResponseFields::set_has_return_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommonResponseFields::clear_has_return_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommonResponseFields::clear_return_code() {
  if (return_code_ != &::google::protobuf::internal::kEmptyString) {
    return_code_->clear();
  }
  clear_has_return_code();
}
inline const ::std::string& CommonResponseFields::return_code() const {
  return *return_code_;
}
inline void CommonResponseFields::set_return_code(const ::std::string& value) {
  set_has_return_code();
  if (return_code_ == &::google::protobuf::internal::kEmptyString) {
    return_code_ = new ::std::string;
  }
  return_code_->assign(value);
}
inline void CommonResponseFields::set_return_code(const char* value) {
  set_has_return_code();
  if (return_code_ == &::google::protobuf::internal::kEmptyString) {
    return_code_ = new ::std::string;
  }
  return_code_->assign(value);
}
inline void CommonResponseFields::set_return_code(const char* value, size_t size) {
  set_has_return_code();
  if (return_code_ == &::google::protobuf::internal::kEmptyString) {
    return_code_ = new ::std::string;
  }
  return_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonResponseFields::mutable_return_code() {
  set_has_return_code();
  if (return_code_ == &::google::protobuf::internal::kEmptyString) {
    return_code_ = new ::std::string;
  }
  return return_code_;
}
inline ::std::string* CommonResponseFields::release_return_code() {
  clear_has_return_code();
  if (return_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = return_code_;
    return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonResponseFields::set_allocated_return_code(::std::string* return_code) {
  if (return_code_ != &::google::protobuf::internal::kEmptyString) {
    delete return_code_;
  }
  if (return_code) {
    set_has_return_code();
    return_code_ = return_code;
  } else {
    clear_has_return_code();
    return_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string return_message = 3;
inline bool CommonResponseFields::has_return_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommonResponseFields::set_has_return_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommonResponseFields::clear_has_return_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommonResponseFields::clear_return_message() {
  if (return_message_ != &::google::protobuf::internal::kEmptyString) {
    return_message_->clear();
  }
  clear_has_return_message();
}
inline const ::std::string& CommonResponseFields::return_message() const {
  return *return_message_;
}
inline void CommonResponseFields::set_return_message(const ::std::string& value) {
  set_has_return_message();
  if (return_message_ == &::google::protobuf::internal::kEmptyString) {
    return_message_ = new ::std::string;
  }
  return_message_->assign(value);
}
inline void CommonResponseFields::set_return_message(const char* value) {
  set_has_return_message();
  if (return_message_ == &::google::protobuf::internal::kEmptyString) {
    return_message_ = new ::std::string;
  }
  return_message_->assign(value);
}
inline void CommonResponseFields::set_return_message(const char* value, size_t size) {
  set_has_return_message();
  if (return_message_ == &::google::protobuf::internal::kEmptyString) {
    return_message_ = new ::std::string;
  }
  return_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonResponseFields::mutable_return_message() {
  set_has_return_message();
  if (return_message_ == &::google::protobuf::internal::kEmptyString) {
    return_message_ = new ::std::string;
  }
  return return_message_;
}
inline ::std::string* CommonResponseFields::release_return_message() {
  clear_has_return_message();
  if (return_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = return_message_;
    return_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonResponseFields::set_allocated_return_message(::std::string* return_message) {
  if (return_message_ != &::google::protobuf::internal::kEmptyString) {
    delete return_message_;
  }
  if (return_message) {
    set_has_return_message();
    return_message_ = return_message;
  } else {
    clear_has_return_message();
    return_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string return_count = 4;
inline bool CommonResponseFields::has_return_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommonResponseFields::set_has_return_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommonResponseFields::clear_has_return_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommonResponseFields::clear_return_count() {
  if (return_count_ != &::google::protobuf::internal::kEmptyString) {
    return_count_->clear();
  }
  clear_has_return_count();
}
inline const ::std::string& CommonResponseFields::return_count() const {
  return *return_count_;
}
inline void CommonResponseFields::set_return_count(const ::std::string& value) {
  set_has_return_count();
  if (return_count_ == &::google::protobuf::internal::kEmptyString) {
    return_count_ = new ::std::string;
  }
  return_count_->assign(value);
}
inline void CommonResponseFields::set_return_count(const char* value) {
  set_has_return_count();
  if (return_count_ == &::google::protobuf::internal::kEmptyString) {
    return_count_ = new ::std::string;
  }
  return_count_->assign(value);
}
inline void CommonResponseFields::set_return_count(const char* value, size_t size) {
  set_has_return_count();
  if (return_count_ == &::google::protobuf::internal::kEmptyString) {
    return_count_ = new ::std::string;
  }
  return_count_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonResponseFields::mutable_return_count() {
  set_has_return_count();
  if (return_count_ == &::google::protobuf::internal::kEmptyString) {
    return_count_ = new ::std::string;
  }
  return return_count_;
}
inline ::std::string* CommonResponseFields::release_return_count() {
  clear_has_return_count();
  if (return_count_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = return_count_;
    return_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonResponseFields::set_allocated_return_count(::std::string* return_count) {
  if (return_count_ != &::google::protobuf::internal::kEmptyString) {
    delete return_count_;
  }
  if (return_count) {
    set_has_return_count();
    return_count_ = return_count;
  } else {
    clear_has_return_count();
    return_count_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string page_info = 5;
inline bool CommonResponseFields::has_page_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommonResponseFields::set_has_page_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommonResponseFields::clear_has_page_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommonResponseFields::clear_page_info() {
  if (page_info_ != &::google::protobuf::internal::kEmptyString) {
    page_info_->clear();
  }
  clear_has_page_info();
}
inline const ::std::string& CommonResponseFields::page_info() const {
  return *page_info_;
}
inline void CommonResponseFields::set_page_info(const ::std::string& value) {
  set_has_page_info();
  if (page_info_ == &::google::protobuf::internal::kEmptyString) {
    page_info_ = new ::std::string;
  }
  page_info_->assign(value);
}
inline void CommonResponseFields::set_page_info(const char* value) {
  set_has_page_info();
  if (page_info_ == &::google::protobuf::internal::kEmptyString) {
    page_info_ = new ::std::string;
  }
  page_info_->assign(value);
}
inline void CommonResponseFields::set_page_info(const char* value, size_t size) {
  set_has_page_info();
  if (page_info_ == &::google::protobuf::internal::kEmptyString) {
    page_info_ = new ::std::string;
  }
  page_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonResponseFields::mutable_page_info() {
  set_has_page_info();
  if (page_info_ == &::google::protobuf::internal::kEmptyString) {
    page_info_ = new ::std::string;
  }
  return page_info_;
}
inline ::std::string* CommonResponseFields::release_page_info() {
  clear_has_page_info();
  if (page_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = page_info_;
    page_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonResponseFields::set_allocated_page_info(::std::string* page_info) {
  if (page_info_ != &::google::protobuf::internal::kEmptyString) {
    delete page_info_;
  }
  if (page_info) {
    set_has_page_info();
    page_info_ = page_info;
  } else {
    clear_has_page_info();
    page_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string message_id = 6;
inline bool CommonResponseFields::has_message_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommonResponseFields::set_has_message_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommonResponseFields::clear_has_message_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommonResponseFields::clear_message_id() {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    message_id_->clear();
  }
  clear_has_message_id();
}
inline const ::std::string& CommonResponseFields::message_id() const {
  return *message_id_;
}
inline void CommonResponseFields::set_message_id(const ::std::string& value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void CommonResponseFields::set_message_id(const char* value) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(value);
}
inline void CommonResponseFields::set_message_id(const char* value, size_t size) {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  message_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommonResponseFields::mutable_message_id() {
  set_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    message_id_ = new ::std::string;
  }
  return message_id_;
}
inline ::std::string* CommonResponseFields::release_message_id() {
  clear_has_message_id();
  if (message_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_id_;
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommonResponseFields::set_allocated_message_id(::std::string* message_id) {
  if (message_id_ != &::google::protobuf::internal::kEmptyString) {
    delete message_id_;
  }
  if (message_id) {
    set_has_message_id();
    message_id_ = message_id;
  } else {
    clear_has_message_id();
    message_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetCrmIdListRequest

// optional .Crm.CommonRequestFields common_fields = 1;
inline bool GetCrmIdListRequest::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCrmIdListRequest::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCrmIdListRequest::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCrmIdListRequest::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonRequestFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonRequestFields& GetCrmIdListRequest::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonRequestFields* GetCrmIdListRequest::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonRequestFields;
  return common_fields_;
}
inline ::Crm::CommonRequestFields* GetCrmIdListRequest::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonRequestFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetCrmIdListRequest::set_allocated_common_fields(::Crm::CommonRequestFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// -------------------------------------------------------------------

// CrmIdItem

// optional string crm_id = 1;
inline bool CrmIdItem::has_crm_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrmIdItem::set_has_crm_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrmIdItem::clear_has_crm_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrmIdItem::clear_crm_id() {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    crm_id_->clear();
  }
  clear_has_crm_id();
}
inline const ::std::string& CrmIdItem::crm_id() const {
  return *crm_id_;
}
inline void CrmIdItem::set_crm_id(const ::std::string& value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void CrmIdItem::set_crm_id(const char* value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void CrmIdItem::set_crm_id(const char* value, size_t size) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CrmIdItem::mutable_crm_id() {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  return crm_id_;
}
inline ::std::string* CrmIdItem::release_crm_id() {
  clear_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crm_id_;
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CrmIdItem::set_allocated_crm_id(::std::string* crm_id) {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    delete crm_id_;
  }
  if (crm_id) {
    set_has_crm_id();
    crm_id_ = crm_id;
  } else {
    clear_has_crm_id();
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string application_type = 2;
inline bool CrmIdItem::has_application_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CrmIdItem::set_has_application_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CrmIdItem::clear_has_application_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CrmIdItem::clear_application_type() {
  if (application_type_ != &::google::protobuf::internal::kEmptyString) {
    application_type_->clear();
  }
  clear_has_application_type();
}
inline const ::std::string& CrmIdItem::application_type() const {
  return *application_type_;
}
inline void CrmIdItem::set_application_type(const ::std::string& value) {
  set_has_application_type();
  if (application_type_ == &::google::protobuf::internal::kEmptyString) {
    application_type_ = new ::std::string;
  }
  application_type_->assign(value);
}
inline void CrmIdItem::set_application_type(const char* value) {
  set_has_application_type();
  if (application_type_ == &::google::protobuf::internal::kEmptyString) {
    application_type_ = new ::std::string;
  }
  application_type_->assign(value);
}
inline void CrmIdItem::set_application_type(const char* value, size_t size) {
  set_has_application_type();
  if (application_type_ == &::google::protobuf::internal::kEmptyString) {
    application_type_ = new ::std::string;
  }
  application_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CrmIdItem::mutable_application_type() {
  set_has_application_type();
  if (application_type_ == &::google::protobuf::internal::kEmptyString) {
    application_type_ = new ::std::string;
  }
  return application_type_;
}
inline ::std::string* CrmIdItem::release_application_type() {
  clear_has_application_type();
  if (application_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = application_type_;
    application_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CrmIdItem::set_allocated_application_type(::std::string* application_type) {
  if (application_type_ != &::google::protobuf::internal::kEmptyString) {
    delete application_type_;
  }
  if (application_type) {
    set_has_application_type();
    application_type_ = application_type;
  } else {
    clear_has_application_type();
    application_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes crm_name = 3;
inline bool CrmIdItem::has_crm_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CrmIdItem::set_has_crm_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CrmIdItem::clear_has_crm_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CrmIdItem::clear_crm_name() {
  if (crm_name_ != &::google::protobuf::internal::kEmptyString) {
    crm_name_->clear();
  }
  clear_has_crm_name();
}
inline const ::std::string& CrmIdItem::crm_name() const {
  return *crm_name_;
}
inline void CrmIdItem::set_crm_name(const ::std::string& value) {
  set_has_crm_name();
  if (crm_name_ == &::google::protobuf::internal::kEmptyString) {
    crm_name_ = new ::std::string;
  }
  crm_name_->assign(value);
}
inline void CrmIdItem::set_crm_name(const char* value) {
  set_has_crm_name();
  if (crm_name_ == &::google::protobuf::internal::kEmptyString) {
    crm_name_ = new ::std::string;
  }
  crm_name_->assign(value);
}
inline void CrmIdItem::set_crm_name(const void* value, size_t size) {
  set_has_crm_name();
  if (crm_name_ == &::google::protobuf::internal::kEmptyString) {
    crm_name_ = new ::std::string;
  }
  crm_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CrmIdItem::mutable_crm_name() {
  set_has_crm_name();
  if (crm_name_ == &::google::protobuf::internal::kEmptyString) {
    crm_name_ = new ::std::string;
  }
  return crm_name_;
}
inline ::std::string* CrmIdItem::release_crm_name() {
  clear_has_crm_name();
  if (crm_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crm_name_;
    crm_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CrmIdItem::set_allocated_crm_name(::std::string* crm_name) {
  if (crm_name_ != &::google::protobuf::internal::kEmptyString) {
    delete crm_name_;
  }
  if (crm_name) {
    set_has_crm_name();
    crm_name_ = crm_name;
  } else {
    clear_has_crm_name();
    crm_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetCrmIdListResponse

// optional .Crm.CommonResponseFields common_fields = 1;
inline bool GetCrmIdListResponse::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCrmIdListResponse::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCrmIdListResponse::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCrmIdListResponse::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonResponseFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonResponseFields& GetCrmIdListResponse::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonResponseFields* GetCrmIdListResponse::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonResponseFields;
  return common_fields_;
}
inline ::Crm::CommonResponseFields* GetCrmIdListResponse::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonResponseFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetCrmIdListResponse::set_allocated_common_fields(::Crm::CommonResponseFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// repeated .Crm.CrmIdItem result = 2;
inline int GetCrmIdListResponse::result_size() const {
  return result_.size();
}
inline void GetCrmIdListResponse::clear_result() {
  result_.Clear();
}
inline const ::Crm::CrmIdItem& GetCrmIdListResponse::result(int index) const {
  return result_.Get(index);
}
inline ::Crm::CrmIdItem* GetCrmIdListResponse::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::Crm::CrmIdItem* GetCrmIdListResponse::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Crm::CrmIdItem >&
GetCrmIdListResponse::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::Crm::CrmIdItem >*
GetCrmIdListResponse::mutable_result() {
  return &result_;
}

// -------------------------------------------------------------------

// GetInstListRequest

// optional .Crm.CommonRequestFields common_fields = 1;
inline bool GetInstListRequest::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetInstListRequest::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetInstListRequest::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetInstListRequest::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonRequestFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonRequestFields& GetInstListRequest::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonRequestFields* GetInstListRequest::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonRequestFields;
  return common_fields_;
}
inline ::Crm::CommonRequestFields* GetInstListRequest::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonRequestFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetInstListRequest::set_allocated_common_fields(::Crm::CommonRequestFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// -------------------------------------------------------------------

// InstitutionItem

// optional string crm_id = 1;
inline bool InstitutionItem::has_crm_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstitutionItem::set_has_crm_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstitutionItem::clear_has_crm_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstitutionItem::clear_crm_id() {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    crm_id_->clear();
  }
  clear_has_crm_id();
}
inline const ::std::string& InstitutionItem::crm_id() const {
  return *crm_id_;
}
inline void InstitutionItem::set_crm_id(const ::std::string& value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void InstitutionItem::set_crm_id(const char* value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void InstitutionItem::set_crm_id(const char* value, size_t size) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_crm_id() {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  return crm_id_;
}
inline ::std::string* InstitutionItem::release_crm_id() {
  clear_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crm_id_;
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_crm_id(::std::string* crm_id) {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    delete crm_id_;
  }
  if (crm_id) {
    set_has_crm_id();
    crm_id_ = crm_id;
  } else {
    clear_has_crm_id();
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inst_id = 2;
inline bool InstitutionItem::has_inst_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstitutionItem::set_has_inst_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstitutionItem::clear_has_inst_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstitutionItem::clear_inst_id() {
  if (inst_id_ != &::google::protobuf::internal::kEmptyString) {
    inst_id_->clear();
  }
  clear_has_inst_id();
}
inline const ::std::string& InstitutionItem::inst_id() const {
  return *inst_id_;
}
inline void InstitutionItem::set_inst_id(const ::std::string& value) {
  set_has_inst_id();
  if (inst_id_ == &::google::protobuf::internal::kEmptyString) {
    inst_id_ = new ::std::string;
  }
  inst_id_->assign(value);
}
inline void InstitutionItem::set_inst_id(const char* value) {
  set_has_inst_id();
  if (inst_id_ == &::google::protobuf::internal::kEmptyString) {
    inst_id_ = new ::std::string;
  }
  inst_id_->assign(value);
}
inline void InstitutionItem::set_inst_id(const char* value, size_t size) {
  set_has_inst_id();
  if (inst_id_ == &::google::protobuf::internal::kEmptyString) {
    inst_id_ = new ::std::string;
  }
  inst_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_inst_id() {
  set_has_inst_id();
  if (inst_id_ == &::google::protobuf::internal::kEmptyString) {
    inst_id_ = new ::std::string;
  }
  return inst_id_;
}
inline ::std::string* InstitutionItem::release_inst_id() {
  clear_has_inst_id();
  if (inst_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inst_id_;
    inst_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_inst_id(::std::string* inst_id) {
  if (inst_id_ != &::google::protobuf::internal::kEmptyString) {
    delete inst_id_;
  }
  if (inst_id) {
    set_has_inst_id();
    inst_id_ = inst_id;
  } else {
    clear_has_inst_id();
    inst_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string company_id = 3;
inline bool InstitutionItem::has_company_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstitutionItem::set_has_company_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstitutionItem::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstitutionItem::clear_company_id() {
  if (company_id_ != &::google::protobuf::internal::kEmptyString) {
    company_id_->clear();
  }
  clear_has_company_id();
}
inline const ::std::string& InstitutionItem::company_id() const {
  return *company_id_;
}
inline void InstitutionItem::set_company_id(const ::std::string& value) {
  set_has_company_id();
  if (company_id_ == &::google::protobuf::internal::kEmptyString) {
    company_id_ = new ::std::string;
  }
  company_id_->assign(value);
}
inline void InstitutionItem::set_company_id(const char* value) {
  set_has_company_id();
  if (company_id_ == &::google::protobuf::internal::kEmptyString) {
    company_id_ = new ::std::string;
  }
  company_id_->assign(value);
}
inline void InstitutionItem::set_company_id(const char* value, size_t size) {
  set_has_company_id();
  if (company_id_ == &::google::protobuf::internal::kEmptyString) {
    company_id_ = new ::std::string;
  }
  company_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_company_id() {
  set_has_company_id();
  if (company_id_ == &::google::protobuf::internal::kEmptyString) {
    company_id_ = new ::std::string;
  }
  return company_id_;
}
inline ::std::string* InstitutionItem::release_company_id() {
  clear_has_company_id();
  if (company_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = company_id_;
    company_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_company_id(::std::string* company_id) {
  if (company_id_ != &::google::protobuf::internal::kEmptyString) {
    delete company_id_;
  }
  if (company_id) {
    set_has_company_id();
    company_id_ = company_id;
  } else {
    clear_has_company_id();
    company_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string qb_id = 4;
inline bool InstitutionItem::has_qb_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstitutionItem::set_has_qb_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstitutionItem::clear_has_qb_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstitutionItem::clear_qb_id() {
  if (qb_id_ != &::google::protobuf::internal::kEmptyString) {
    qb_id_->clear();
  }
  clear_has_qb_id();
}
inline const ::std::string& InstitutionItem::qb_id() const {
  return *qb_id_;
}
inline void InstitutionItem::set_qb_id(const ::std::string& value) {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  qb_id_->assign(value);
}
inline void InstitutionItem::set_qb_id(const char* value) {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  qb_id_->assign(value);
}
inline void InstitutionItem::set_qb_id(const char* value, size_t size) {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  qb_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_qb_id() {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  return qb_id_;
}
inline ::std::string* InstitutionItem::release_qb_id() {
  clear_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qb_id_;
    qb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_qb_id(::std::string* qb_id) {
  if (qb_id_ != &::google::protobuf::internal::kEmptyString) {
    delete qb_id_;
  }
  if (qb_id) {
    set_has_qb_id();
    qb_id_ = qb_id;
  } else {
    clear_has_qb_id();
    qb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string idb_key = 5;
inline bool InstitutionItem::has_idb_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstitutionItem::set_has_idb_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstitutionItem::clear_has_idb_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstitutionItem::clear_idb_key() {
  if (idb_key_ != &::google::protobuf::internal::kEmptyString) {
    idb_key_->clear();
  }
  clear_has_idb_key();
}
inline const ::std::string& InstitutionItem::idb_key() const {
  return *idb_key_;
}
inline void InstitutionItem::set_idb_key(const ::std::string& value) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(value);
}
inline void InstitutionItem::set_idb_key(const char* value) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(value);
}
inline void InstitutionItem::set_idb_key(const char* value, size_t size) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_idb_key() {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  return idb_key_;
}
inline ::std::string* InstitutionItem::release_idb_key() {
  clear_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idb_key_;
    idb_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_idb_key(::std::string* idb_key) {
  if (idb_key_ != &::google::protobuf::internal::kEmptyString) {
    delete idb_key_;
  }
  if (idb_key) {
    set_has_idb_key();
    idb_key_ = idb_key;
  } else {
    clear_has_idb_key();
    idb_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes inst_short_name_cn = 6;
inline bool InstitutionItem::has_inst_short_name_cn() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstitutionItem::set_has_inst_short_name_cn() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InstitutionItem::clear_has_inst_short_name_cn() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InstitutionItem::clear_inst_short_name_cn() {
  if (inst_short_name_cn_ != &::google::protobuf::internal::kEmptyString) {
    inst_short_name_cn_->clear();
  }
  clear_has_inst_short_name_cn();
}
inline const ::std::string& InstitutionItem::inst_short_name_cn() const {
  return *inst_short_name_cn_;
}
inline void InstitutionItem::set_inst_short_name_cn(const ::std::string& value) {
  set_has_inst_short_name_cn();
  if (inst_short_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    inst_short_name_cn_ = new ::std::string;
  }
  inst_short_name_cn_->assign(value);
}
inline void InstitutionItem::set_inst_short_name_cn(const char* value) {
  set_has_inst_short_name_cn();
  if (inst_short_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    inst_short_name_cn_ = new ::std::string;
  }
  inst_short_name_cn_->assign(value);
}
inline void InstitutionItem::set_inst_short_name_cn(const void* value, size_t size) {
  set_has_inst_short_name_cn();
  if (inst_short_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    inst_short_name_cn_ = new ::std::string;
  }
  inst_short_name_cn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_inst_short_name_cn() {
  set_has_inst_short_name_cn();
  if (inst_short_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    inst_short_name_cn_ = new ::std::string;
  }
  return inst_short_name_cn_;
}
inline ::std::string* InstitutionItem::release_inst_short_name_cn() {
  clear_has_inst_short_name_cn();
  if (inst_short_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inst_short_name_cn_;
    inst_short_name_cn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_inst_short_name_cn(::std::string* inst_short_name_cn) {
  if (inst_short_name_cn_ != &::google::protobuf::internal::kEmptyString) {
    delete inst_short_name_cn_;
  }
  if (inst_short_name_cn) {
    set_has_inst_short_name_cn();
    inst_short_name_cn_ = inst_short_name_cn;
  } else {
    clear_has_inst_short_name_cn();
    inst_short_name_cn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pinyin = 7;
inline bool InstitutionItem::has_pinyin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstitutionItem::set_has_pinyin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InstitutionItem::clear_has_pinyin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InstitutionItem::clear_pinyin() {
  if (pinyin_ != &::google::protobuf::internal::kEmptyString) {
    pinyin_->clear();
  }
  clear_has_pinyin();
}
inline const ::std::string& InstitutionItem::pinyin() const {
  return *pinyin_;
}
inline void InstitutionItem::set_pinyin(const ::std::string& value) {
  set_has_pinyin();
  if (pinyin_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_ = new ::std::string;
  }
  pinyin_->assign(value);
}
inline void InstitutionItem::set_pinyin(const char* value) {
  set_has_pinyin();
  if (pinyin_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_ = new ::std::string;
  }
  pinyin_->assign(value);
}
inline void InstitutionItem::set_pinyin(const char* value, size_t size) {
  set_has_pinyin();
  if (pinyin_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_ = new ::std::string;
  }
  pinyin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_pinyin() {
  set_has_pinyin();
  if (pinyin_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_ = new ::std::string;
  }
  return pinyin_;
}
inline ::std::string* InstitutionItem::release_pinyin() {
  clear_has_pinyin();
  if (pinyin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pinyin_;
    pinyin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_pinyin(::std::string* pinyin) {
  if (pinyin_ != &::google::protobuf::internal::kEmptyString) {
    delete pinyin_;
  }
  if (pinyin) {
    set_has_pinyin();
    pinyin_ = pinyin;
  } else {
    clear_has_pinyin();
    pinyin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pinyin_full = 8;
inline bool InstitutionItem::has_pinyin_full() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InstitutionItem::set_has_pinyin_full() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InstitutionItem::clear_has_pinyin_full() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InstitutionItem::clear_pinyin_full() {
  if (pinyin_full_ != &::google::protobuf::internal::kEmptyString) {
    pinyin_full_->clear();
  }
  clear_has_pinyin_full();
}
inline const ::std::string& InstitutionItem::pinyin_full() const {
  return *pinyin_full_;
}
inline void InstitutionItem::set_pinyin_full(const ::std::string& value) {
  set_has_pinyin_full();
  if (pinyin_full_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_full_ = new ::std::string;
  }
  pinyin_full_->assign(value);
}
inline void InstitutionItem::set_pinyin_full(const char* value) {
  set_has_pinyin_full();
  if (pinyin_full_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_full_ = new ::std::string;
  }
  pinyin_full_->assign(value);
}
inline void InstitutionItem::set_pinyin_full(const char* value, size_t size) {
  set_has_pinyin_full();
  if (pinyin_full_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_full_ = new ::std::string;
  }
  pinyin_full_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_pinyin_full() {
  set_has_pinyin_full();
  if (pinyin_full_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_full_ = new ::std::string;
  }
  return pinyin_full_;
}
inline ::std::string* InstitutionItem::release_pinyin_full() {
  clear_has_pinyin_full();
  if (pinyin_full_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pinyin_full_;
    pinyin_full_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_pinyin_full(::std::string* pinyin_full) {
  if (pinyin_full_ != &::google::protobuf::internal::kEmptyString) {
    delete pinyin_full_;
  }
  if (pinyin_full) {
    set_has_pinyin_full();
    pinyin_full_ = pinyin_full;
  } else {
    clear_has_pinyin_full();
    pinyin_full_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inst_short_name_en = 9;
inline bool InstitutionItem::has_inst_short_name_en() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InstitutionItem::set_has_inst_short_name_en() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InstitutionItem::clear_has_inst_short_name_en() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InstitutionItem::clear_inst_short_name_en() {
  if (inst_short_name_en_ != &::google::protobuf::internal::kEmptyString) {
    inst_short_name_en_->clear();
  }
  clear_has_inst_short_name_en();
}
inline const ::std::string& InstitutionItem::inst_short_name_en() const {
  return *inst_short_name_en_;
}
inline void InstitutionItem::set_inst_short_name_en(const ::std::string& value) {
  set_has_inst_short_name_en();
  if (inst_short_name_en_ == &::google::protobuf::internal::kEmptyString) {
    inst_short_name_en_ = new ::std::string;
  }
  inst_short_name_en_->assign(value);
}
inline void InstitutionItem::set_inst_short_name_en(const char* value) {
  set_has_inst_short_name_en();
  if (inst_short_name_en_ == &::google::protobuf::internal::kEmptyString) {
    inst_short_name_en_ = new ::std::string;
  }
  inst_short_name_en_->assign(value);
}
inline void InstitutionItem::set_inst_short_name_en(const char* value, size_t size) {
  set_has_inst_short_name_en();
  if (inst_short_name_en_ == &::google::protobuf::internal::kEmptyString) {
    inst_short_name_en_ = new ::std::string;
  }
  inst_short_name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_inst_short_name_en() {
  set_has_inst_short_name_en();
  if (inst_short_name_en_ == &::google::protobuf::internal::kEmptyString) {
    inst_short_name_en_ = new ::std::string;
  }
  return inst_short_name_en_;
}
inline ::std::string* InstitutionItem::release_inst_short_name_en() {
  clear_has_inst_short_name_en();
  if (inst_short_name_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inst_short_name_en_;
    inst_short_name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_inst_short_name_en(::std::string* inst_short_name_en) {
  if (inst_short_name_en_ != &::google::protobuf::internal::kEmptyString) {
    delete inst_short_name_en_;
  }
  if (inst_short_name_en) {
    set_has_inst_short_name_en();
    inst_short_name_en_ = inst_short_name_en;
  } else {
    clear_has_inst_short_name_en();
    inst_short_name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes inst_full_name_cn = 10;
inline bool InstitutionItem::has_inst_full_name_cn() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InstitutionItem::set_has_inst_full_name_cn() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InstitutionItem::clear_has_inst_full_name_cn() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InstitutionItem::clear_inst_full_name_cn() {
  if (inst_full_name_cn_ != &::google::protobuf::internal::kEmptyString) {
    inst_full_name_cn_->clear();
  }
  clear_has_inst_full_name_cn();
}
inline const ::std::string& InstitutionItem::inst_full_name_cn() const {
  return *inst_full_name_cn_;
}
inline void InstitutionItem::set_inst_full_name_cn(const ::std::string& value) {
  set_has_inst_full_name_cn();
  if (inst_full_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    inst_full_name_cn_ = new ::std::string;
  }
  inst_full_name_cn_->assign(value);
}
inline void InstitutionItem::set_inst_full_name_cn(const char* value) {
  set_has_inst_full_name_cn();
  if (inst_full_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    inst_full_name_cn_ = new ::std::string;
  }
  inst_full_name_cn_->assign(value);
}
inline void InstitutionItem::set_inst_full_name_cn(const void* value, size_t size) {
  set_has_inst_full_name_cn();
  if (inst_full_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    inst_full_name_cn_ = new ::std::string;
  }
  inst_full_name_cn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_inst_full_name_cn() {
  set_has_inst_full_name_cn();
  if (inst_full_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    inst_full_name_cn_ = new ::std::string;
  }
  return inst_full_name_cn_;
}
inline ::std::string* InstitutionItem::release_inst_full_name_cn() {
  clear_has_inst_full_name_cn();
  if (inst_full_name_cn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inst_full_name_cn_;
    inst_full_name_cn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_inst_full_name_cn(::std::string* inst_full_name_cn) {
  if (inst_full_name_cn_ != &::google::protobuf::internal::kEmptyString) {
    delete inst_full_name_cn_;
  }
  if (inst_full_name_cn) {
    set_has_inst_full_name_cn();
    inst_full_name_cn_ = inst_full_name_cn;
  } else {
    clear_has_inst_full_name_cn();
    inst_full_name_cn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inst_full_name_en = 11;
inline bool InstitutionItem::has_inst_full_name_en() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InstitutionItem::set_has_inst_full_name_en() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InstitutionItem::clear_has_inst_full_name_en() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InstitutionItem::clear_inst_full_name_en() {
  if (inst_full_name_en_ != &::google::protobuf::internal::kEmptyString) {
    inst_full_name_en_->clear();
  }
  clear_has_inst_full_name_en();
}
inline const ::std::string& InstitutionItem::inst_full_name_en() const {
  return *inst_full_name_en_;
}
inline void InstitutionItem::set_inst_full_name_en(const ::std::string& value) {
  set_has_inst_full_name_en();
  if (inst_full_name_en_ == &::google::protobuf::internal::kEmptyString) {
    inst_full_name_en_ = new ::std::string;
  }
  inst_full_name_en_->assign(value);
}
inline void InstitutionItem::set_inst_full_name_en(const char* value) {
  set_has_inst_full_name_en();
  if (inst_full_name_en_ == &::google::protobuf::internal::kEmptyString) {
    inst_full_name_en_ = new ::std::string;
  }
  inst_full_name_en_->assign(value);
}
inline void InstitutionItem::set_inst_full_name_en(const char* value, size_t size) {
  set_has_inst_full_name_en();
  if (inst_full_name_en_ == &::google::protobuf::internal::kEmptyString) {
    inst_full_name_en_ = new ::std::string;
  }
  inst_full_name_en_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_inst_full_name_en() {
  set_has_inst_full_name_en();
  if (inst_full_name_en_ == &::google::protobuf::internal::kEmptyString) {
    inst_full_name_en_ = new ::std::string;
  }
  return inst_full_name_en_;
}
inline ::std::string* InstitutionItem::release_inst_full_name_en() {
  clear_has_inst_full_name_en();
  if (inst_full_name_en_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inst_full_name_en_;
    inst_full_name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_inst_full_name_en(::std::string* inst_full_name_en) {
  if (inst_full_name_en_ != &::google::protobuf::internal::kEmptyString) {
    delete inst_full_name_en_;
  }
  if (inst_full_name_en) {
    set_has_inst_full_name_en();
    inst_full_name_en_ = inst_full_name_en;
  } else {
    clear_has_inst_full_name_en();
    inst_full_name_en_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inst_code = 12;
inline bool InstitutionItem::has_inst_code() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InstitutionItem::set_has_inst_code() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InstitutionItem::clear_has_inst_code() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InstitutionItem::clear_inst_code() {
  if (inst_code_ != &::google::protobuf::internal::kEmptyString) {
    inst_code_->clear();
  }
  clear_has_inst_code();
}
inline const ::std::string& InstitutionItem::inst_code() const {
  return *inst_code_;
}
inline void InstitutionItem::set_inst_code(const ::std::string& value) {
  set_has_inst_code();
  if (inst_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_code_ = new ::std::string;
  }
  inst_code_->assign(value);
}
inline void InstitutionItem::set_inst_code(const char* value) {
  set_has_inst_code();
  if (inst_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_code_ = new ::std::string;
  }
  inst_code_->assign(value);
}
inline void InstitutionItem::set_inst_code(const char* value, size_t size) {
  set_has_inst_code();
  if (inst_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_code_ = new ::std::string;
  }
  inst_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_inst_code() {
  set_has_inst_code();
  if (inst_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_code_ = new ::std::string;
  }
  return inst_code_;
}
inline ::std::string* InstitutionItem::release_inst_code() {
  clear_has_inst_code();
  if (inst_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inst_code_;
    inst_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_inst_code(::std::string* inst_code) {
  if (inst_code_ != &::google::protobuf::internal::kEmptyString) {
    delete inst_code_;
  }
  if (inst_code) {
    set_has_inst_code();
    inst_code_ = inst_code;
  } else {
    clear_has_inst_code();
    inst_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inst_city_code = 13;
inline bool InstitutionItem::has_inst_city_code() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InstitutionItem::set_has_inst_city_code() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InstitutionItem::clear_has_inst_city_code() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InstitutionItem::clear_inst_city_code() {
  if (inst_city_code_ != &::google::protobuf::internal::kEmptyString) {
    inst_city_code_->clear();
  }
  clear_has_inst_city_code();
}
inline const ::std::string& InstitutionItem::inst_city_code() const {
  return *inst_city_code_;
}
inline void InstitutionItem::set_inst_city_code(const ::std::string& value) {
  set_has_inst_city_code();
  if (inst_city_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_city_code_ = new ::std::string;
  }
  inst_city_code_->assign(value);
}
inline void InstitutionItem::set_inst_city_code(const char* value) {
  set_has_inst_city_code();
  if (inst_city_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_city_code_ = new ::std::string;
  }
  inst_city_code_->assign(value);
}
inline void InstitutionItem::set_inst_city_code(const char* value, size_t size) {
  set_has_inst_city_code();
  if (inst_city_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_city_code_ = new ::std::string;
  }
  inst_city_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_inst_city_code() {
  set_has_inst_city_code();
  if (inst_city_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_city_code_ = new ::std::string;
  }
  return inst_city_code_;
}
inline ::std::string* InstitutionItem::release_inst_city_code() {
  clear_has_inst_city_code();
  if (inst_city_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inst_city_code_;
    inst_city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_inst_city_code(::std::string* inst_city_code) {
  if (inst_city_code_ != &::google::protobuf::internal::kEmptyString) {
    delete inst_city_code_;
  }
  if (inst_city_code) {
    set_has_inst_city_code();
    inst_city_code_ = inst_city_code;
  } else {
    clear_has_inst_city_code();
    inst_city_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes inst_city_value = 14;
inline bool InstitutionItem::has_inst_city_value() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InstitutionItem::set_has_inst_city_value() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InstitutionItem::clear_has_inst_city_value() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InstitutionItem::clear_inst_city_value() {
  if (inst_city_value_ != &::google::protobuf::internal::kEmptyString) {
    inst_city_value_->clear();
  }
  clear_has_inst_city_value();
}
inline const ::std::string& InstitutionItem::inst_city_value() const {
  return *inst_city_value_;
}
inline void InstitutionItem::set_inst_city_value(const ::std::string& value) {
  set_has_inst_city_value();
  if (inst_city_value_ == &::google::protobuf::internal::kEmptyString) {
    inst_city_value_ = new ::std::string;
  }
  inst_city_value_->assign(value);
}
inline void InstitutionItem::set_inst_city_value(const char* value) {
  set_has_inst_city_value();
  if (inst_city_value_ == &::google::protobuf::internal::kEmptyString) {
    inst_city_value_ = new ::std::string;
  }
  inst_city_value_->assign(value);
}
inline void InstitutionItem::set_inst_city_value(const void* value, size_t size) {
  set_has_inst_city_value();
  if (inst_city_value_ == &::google::protobuf::internal::kEmptyString) {
    inst_city_value_ = new ::std::string;
  }
  inst_city_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_inst_city_value() {
  set_has_inst_city_value();
  if (inst_city_value_ == &::google::protobuf::internal::kEmptyString) {
    inst_city_value_ = new ::std::string;
  }
  return inst_city_value_;
}
inline ::std::string* InstitutionItem::release_inst_city_value() {
  clear_has_inst_city_value();
  if (inst_city_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inst_city_value_;
    inst_city_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_inst_city_value(::std::string* inst_city_value) {
  if (inst_city_value_ != &::google::protobuf::internal::kEmptyString) {
    delete inst_city_value_;
  }
  if (inst_city_value) {
    set_has_inst_city_value();
    inst_city_value_ = inst_city_value;
  } else {
    clear_has_inst_city_value();
    inst_city_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes desc = 15;
inline bool InstitutionItem::has_desc() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InstitutionItem::set_has_desc() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InstitutionItem::clear_has_desc() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InstitutionItem::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& InstitutionItem::desc() const {
  return *desc_;
}
inline void InstitutionItem::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void InstitutionItem::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void InstitutionItem::set_desc(const void* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* InstitutionItem::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string update_time = 16;
inline bool InstitutionItem::has_update_time() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InstitutionItem::set_has_update_time() {
  _has_bits_[0] |= 0x00008000u;
}
inline void InstitutionItem::clear_has_update_time() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void InstitutionItem::clear_update_time() {
  if (update_time_ != &::google::protobuf::internal::kEmptyString) {
    update_time_->clear();
  }
  clear_has_update_time();
}
inline const ::std::string& InstitutionItem::update_time() const {
  return *update_time_;
}
inline void InstitutionItem::set_update_time(const ::std::string& value) {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::kEmptyString) {
    update_time_ = new ::std::string;
  }
  update_time_->assign(value);
}
inline void InstitutionItem::set_update_time(const char* value) {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::kEmptyString) {
    update_time_ = new ::std::string;
  }
  update_time_->assign(value);
}
inline void InstitutionItem::set_update_time(const char* value, size_t size) {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::kEmptyString) {
    update_time_ = new ::std::string;
  }
  update_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_update_time() {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::kEmptyString) {
    update_time_ = new ::std::string;
  }
  return update_time_;
}
inline ::std::string* InstitutionItem::release_update_time() {
  clear_has_update_time();
  if (update_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = update_time_;
    update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_update_time(::std::string* update_time) {
  if (update_time_ != &::google::protobuf::internal::kEmptyString) {
    delete update_time_;
  }
  if (update_time) {
    set_has_update_time();
    update_time_ = update_time;
  } else {
    clear_has_update_time();
    update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inst_type = 17;
inline bool InstitutionItem::has_inst_type() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void InstitutionItem::set_has_inst_type() {
  _has_bits_[0] |= 0x00010000u;
}
inline void InstitutionItem::clear_has_inst_type() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void InstitutionItem::clear_inst_type() {
  if (inst_type_ != &::google::protobuf::internal::kEmptyString) {
    inst_type_->clear();
  }
  clear_has_inst_type();
}
inline const ::std::string& InstitutionItem::inst_type() const {
  return *inst_type_;
}
inline void InstitutionItem::set_inst_type(const ::std::string& value) {
  set_has_inst_type();
  if (inst_type_ == &::google::protobuf::internal::kEmptyString) {
    inst_type_ = new ::std::string;
  }
  inst_type_->assign(value);
}
inline void InstitutionItem::set_inst_type(const char* value) {
  set_has_inst_type();
  if (inst_type_ == &::google::protobuf::internal::kEmptyString) {
    inst_type_ = new ::std::string;
  }
  inst_type_->assign(value);
}
inline void InstitutionItem::set_inst_type(const char* value, size_t size) {
  set_has_inst_type();
  if (inst_type_ == &::google::protobuf::internal::kEmptyString) {
    inst_type_ = new ::std::string;
  }
  inst_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionItem::mutable_inst_type() {
  set_has_inst_type();
  if (inst_type_ == &::google::protobuf::internal::kEmptyString) {
    inst_type_ = new ::std::string;
  }
  return inst_type_;
}
inline ::std::string* InstitutionItem::release_inst_type() {
  clear_has_inst_type();
  if (inst_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inst_type_;
    inst_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionItem::set_allocated_inst_type(::std::string* inst_type) {
  if (inst_type_ != &::google::protobuf::internal::kEmptyString) {
    delete inst_type_;
  }
  if (inst_type) {
    set_has_inst_type();
    inst_type_ = inst_type;
  } else {
    clear_has_inst_type();
    inst_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_internal = 18;
inline bool InstitutionItem::has_is_internal() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void InstitutionItem::set_has_is_internal() {
  _has_bits_[0] |= 0x00020000u;
}
inline void InstitutionItem::clear_has_is_internal() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void InstitutionItem::clear_is_internal() {
  is_internal_ = false;
  clear_has_is_internal();
}
inline bool InstitutionItem::is_internal() const {
  return is_internal_;
}
inline void InstitutionItem::set_is_internal(bool value) {
  set_has_is_internal();
  is_internal_ = value;
}

// -------------------------------------------------------------------

// GetInstListResponse

// optional .Crm.CommonResponseFields common_fields = 1;
inline bool GetInstListResponse::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetInstListResponse::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetInstListResponse::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetInstListResponse::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonResponseFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonResponseFields& GetInstListResponse::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonResponseFields* GetInstListResponse::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonResponseFields;
  return common_fields_;
}
inline ::Crm::CommonResponseFields* GetInstListResponse::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonResponseFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetInstListResponse::set_allocated_common_fields(::Crm::CommonResponseFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// repeated .Crm.InstitutionItem result = 2;
inline int GetInstListResponse::result_size() const {
  return result_.size();
}
inline void GetInstListResponse::clear_result() {
  result_.Clear();
}
inline const ::Crm::InstitutionItem& GetInstListResponse::result(int index) const {
  return result_.Get(index);
}
inline ::Crm::InstitutionItem* GetInstListResponse::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::Crm::InstitutionItem* GetInstListResponse::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Crm::InstitutionItem >&
GetInstListResponse::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::Crm::InstitutionItem >*
GetInstListResponse::mutable_result() {
  return &result_;
}

// -------------------------------------------------------------------

// GetCtctListRequest

// optional .Crm.CommonRequestFields common_fields = 1;
inline bool GetCtctListRequest::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCtctListRequest::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCtctListRequest::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCtctListRequest::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonRequestFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonRequestFields& GetCtctListRequest::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonRequestFields* GetCtctListRequest::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonRequestFields;
  return common_fields_;
}
inline ::Crm::CommonRequestFields* GetCtctListRequest::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonRequestFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetCtctListRequest::set_allocated_common_fields(::Crm::CommonRequestFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// -------------------------------------------------------------------

// AccountMappingItem

// optional string qb_id = 1;
inline bool AccountMappingItem::has_qb_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountMappingItem::set_has_qb_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountMappingItem::clear_has_qb_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountMappingItem::clear_qb_id() {
  if (qb_id_ != &::google::protobuf::internal::kEmptyString) {
    qb_id_->clear();
  }
  clear_has_qb_id();
}
inline const ::std::string& AccountMappingItem::qb_id() const {
  return *qb_id_;
}
inline void AccountMappingItem::set_qb_id(const ::std::string& value) {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  qb_id_->assign(value);
}
inline void AccountMappingItem::set_qb_id(const char* value) {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  qb_id_->assign(value);
}
inline void AccountMappingItem::set_qb_id(const char* value, size_t size) {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  qb_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountMappingItem::mutable_qb_id() {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  return qb_id_;
}
inline ::std::string* AccountMappingItem::release_qb_id() {
  clear_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qb_id_;
    qb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountMappingItem::set_allocated_qb_id(::std::string* qb_id) {
  if (qb_id_ != &::google::protobuf::internal::kEmptyString) {
    delete qb_id_;
  }
  if (qb_id) {
    set_has_qb_id();
    qb_id_ = qb_id;
  } else {
    clear_has_qb_id();
    qb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string idb_key = 2;
inline bool AccountMappingItem::has_idb_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountMappingItem::set_has_idb_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountMappingItem::clear_has_idb_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountMappingItem::clear_idb_key() {
  if (idb_key_ != &::google::protobuf::internal::kEmptyString) {
    idb_key_->clear();
  }
  clear_has_idb_key();
}
inline const ::std::string& AccountMappingItem::idb_key() const {
  return *idb_key_;
}
inline void AccountMappingItem::set_idb_key(const ::std::string& value) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(value);
}
inline void AccountMappingItem::set_idb_key(const char* value) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(value);
}
inline void AccountMappingItem::set_idb_key(const char* value, size_t size) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountMappingItem::mutable_idb_key() {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  return idb_key_;
}
inline ::std::string* AccountMappingItem::release_idb_key() {
  clear_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idb_key_;
    idb_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountMappingItem::set_allocated_idb_key(::std::string* idb_key) {
  if (idb_key_ != &::google::protobuf::internal::kEmptyString) {
    delete idb_key_;
  }
  if (idb_key) {
    set_has_idb_key();
    idb_key_ = idb_key;
  } else {
    clear_has_idb_key();
    idb_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account_id = 3;
inline bool AccountMappingItem::has_account_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountMappingItem::set_has_account_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountMappingItem::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountMappingItem::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& AccountMappingItem::account_id() const {
  return *account_id_;
}
inline void AccountMappingItem::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AccountMappingItem::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AccountMappingItem::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountMappingItem::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* AccountMappingItem::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountMappingItem::set_allocated_account_id(::std::string* account_id) {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    delete account_id_;
  }
  if (account_id) {
    set_has_account_id();
    account_id_ = account_id;
  } else {
    clear_has_account_id();
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string team_id = 4;
inline bool AccountMappingItem::has_team_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountMappingItem::set_has_team_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountMappingItem::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountMappingItem::clear_team_id() {
  if (team_id_ != &::google::protobuf::internal::kEmptyString) {
    team_id_->clear();
  }
  clear_has_team_id();
}
inline const ::std::string& AccountMappingItem::team_id() const {
  return *team_id_;
}
inline void AccountMappingItem::set_team_id(const ::std::string& value) {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  team_id_->assign(value);
}
inline void AccountMappingItem::set_team_id(const char* value) {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  team_id_->assign(value);
}
inline void AccountMappingItem::set_team_id(const char* value, size_t size) {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  team_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountMappingItem::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  return team_id_;
}
inline ::std::string* AccountMappingItem::release_team_id() {
  clear_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = team_id_;
    team_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountMappingItem::set_allocated_team_id(::std::string* team_id) {
  if (team_id_ != &::google::protobuf::internal::kEmptyString) {
    delete team_id_;
  }
  if (team_id) {
    set_has_team_id();
    team_id_ = team_id;
  } else {
    clear_has_team_id();
    team_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string crm_id = 5;
inline bool AccountMappingItem::has_crm_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountMappingItem::set_has_crm_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountMappingItem::clear_has_crm_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountMappingItem::clear_crm_id() {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    crm_id_->clear();
  }
  clear_has_crm_id();
}
inline const ::std::string& AccountMappingItem::crm_id() const {
  return *crm_id_;
}
inline void AccountMappingItem::set_crm_id(const ::std::string& value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void AccountMappingItem::set_crm_id(const char* value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void AccountMappingItem::set_crm_id(const char* value, size_t size) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountMappingItem::mutable_crm_id() {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  return crm_id_;
}
inline ::std::string* AccountMappingItem::release_crm_id() {
  clear_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crm_id_;
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountMappingItem::set_allocated_crm_id(::std::string* crm_id) {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    delete crm_id_;
  }
  if (crm_id) {
    set_has_crm_id();
    crm_id_ = crm_id;
  } else {
    clear_has_crm_id();
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ctct_id = 6;
inline bool AccountMappingItem::has_ctct_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountMappingItem::set_has_ctct_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountMappingItem::clear_has_ctct_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountMappingItem::clear_ctct_id() {
  if (ctct_id_ != &::google::protobuf::internal::kEmptyString) {
    ctct_id_->clear();
  }
  clear_has_ctct_id();
}
inline const ::std::string& AccountMappingItem::ctct_id() const {
  return *ctct_id_;
}
inline void AccountMappingItem::set_ctct_id(const ::std::string& value) {
  set_has_ctct_id();
  if (ctct_id_ == &::google::protobuf::internal::kEmptyString) {
    ctct_id_ = new ::std::string;
  }
  ctct_id_->assign(value);
}
inline void AccountMappingItem::set_ctct_id(const char* value) {
  set_has_ctct_id();
  if (ctct_id_ == &::google::protobuf::internal::kEmptyString) {
    ctct_id_ = new ::std::string;
  }
  ctct_id_->assign(value);
}
inline void AccountMappingItem::set_ctct_id(const char* value, size_t size) {
  set_has_ctct_id();
  if (ctct_id_ == &::google::protobuf::internal::kEmptyString) {
    ctct_id_ = new ::std::string;
  }
  ctct_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountMappingItem::mutable_ctct_id() {
  set_has_ctct_id();
  if (ctct_id_ == &::google::protobuf::internal::kEmptyString) {
    ctct_id_ = new ::std::string;
  }
  return ctct_id_;
}
inline ::std::string* AccountMappingItem::release_ctct_id() {
  clear_has_ctct_id();
  if (ctct_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ctct_id_;
    ctct_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountMappingItem::set_allocated_ctct_id(::std::string* ctct_id) {
  if (ctct_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ctct_id_;
  }
  if (ctct_id) {
    set_has_ctct_id();
    ctct_id_ = ctct_id;
  } else {
    clear_has_ctct_id();
    ctct_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContactItem

// optional string crm_id = 1;
inline bool ContactItem::has_crm_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactItem::set_has_crm_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactItem::clear_has_crm_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactItem::clear_crm_id() {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    crm_id_->clear();
  }
  clear_has_crm_id();
}
inline const ::std::string& ContactItem::crm_id() const {
  return *crm_id_;
}
inline void ContactItem::set_crm_id(const ::std::string& value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void ContactItem::set_crm_id(const char* value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void ContactItem::set_crm_id(const char* value, size_t size) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_crm_id() {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  return crm_id_;
}
inline ::std::string* ContactItem::release_crm_id() {
  clear_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crm_id_;
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_crm_id(::std::string* crm_id) {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    delete crm_id_;
  }
  if (crm_id) {
    set_has_crm_id();
    crm_id_ = crm_id;
  } else {
    clear_has_crm_id();
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ctct_id = 2;
inline bool ContactItem::has_ctct_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactItem::set_has_ctct_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactItem::clear_has_ctct_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactItem::clear_ctct_id() {
  if (ctct_id_ != &::google::protobuf::internal::kEmptyString) {
    ctct_id_->clear();
  }
  clear_has_ctct_id();
}
inline const ::std::string& ContactItem::ctct_id() const {
  return *ctct_id_;
}
inline void ContactItem::set_ctct_id(const ::std::string& value) {
  set_has_ctct_id();
  if (ctct_id_ == &::google::protobuf::internal::kEmptyString) {
    ctct_id_ = new ::std::string;
  }
  ctct_id_->assign(value);
}
inline void ContactItem::set_ctct_id(const char* value) {
  set_has_ctct_id();
  if (ctct_id_ == &::google::protobuf::internal::kEmptyString) {
    ctct_id_ = new ::std::string;
  }
  ctct_id_->assign(value);
}
inline void ContactItem::set_ctct_id(const char* value, size_t size) {
  set_has_ctct_id();
  if (ctct_id_ == &::google::protobuf::internal::kEmptyString) {
    ctct_id_ = new ::std::string;
  }
  ctct_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_ctct_id() {
  set_has_ctct_id();
  if (ctct_id_ == &::google::protobuf::internal::kEmptyString) {
    ctct_id_ = new ::std::string;
  }
  return ctct_id_;
}
inline ::std::string* ContactItem::release_ctct_id() {
  clear_has_ctct_id();
  if (ctct_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ctct_id_;
    ctct_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_ctct_id(::std::string* ctct_id) {
  if (ctct_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ctct_id_;
  }
  if (ctct_id) {
    set_has_ctct_id();
    ctct_id_ = ctct_id;
  } else {
    clear_has_ctct_id();
    ctct_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string company_id = 3;
inline bool ContactItem::has_company_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactItem::set_has_company_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactItem::clear_has_company_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactItem::clear_company_id() {
  if (company_id_ != &::google::protobuf::internal::kEmptyString) {
    company_id_->clear();
  }
  clear_has_company_id();
}
inline const ::std::string& ContactItem::company_id() const {
  return *company_id_;
}
inline void ContactItem::set_company_id(const ::std::string& value) {
  set_has_company_id();
  if (company_id_ == &::google::protobuf::internal::kEmptyString) {
    company_id_ = new ::std::string;
  }
  company_id_->assign(value);
}
inline void ContactItem::set_company_id(const char* value) {
  set_has_company_id();
  if (company_id_ == &::google::protobuf::internal::kEmptyString) {
    company_id_ = new ::std::string;
  }
  company_id_->assign(value);
}
inline void ContactItem::set_company_id(const char* value, size_t size) {
  set_has_company_id();
  if (company_id_ == &::google::protobuf::internal::kEmptyString) {
    company_id_ = new ::std::string;
  }
  company_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_company_id() {
  set_has_company_id();
  if (company_id_ == &::google::protobuf::internal::kEmptyString) {
    company_id_ = new ::std::string;
  }
  return company_id_;
}
inline ::std::string* ContactItem::release_company_id() {
  clear_has_company_id();
  if (company_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = company_id_;
    company_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_company_id(::std::string* company_id) {
  if (company_id_ != &::google::protobuf::internal::kEmptyString) {
    delete company_id_;
  }
  if (company_id) {
    set_has_company_id();
    company_id_ = company_id;
  } else {
    clear_has_company_id();
    company_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string qb_id = 4;
inline bool ContactItem::has_qb_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContactItem::set_has_qb_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContactItem::clear_has_qb_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContactItem::clear_qb_id() {
  if (qb_id_ != &::google::protobuf::internal::kEmptyString) {
    qb_id_->clear();
  }
  clear_has_qb_id();
}
inline const ::std::string& ContactItem::qb_id() const {
  return *qb_id_;
}
inline void ContactItem::set_qb_id(const ::std::string& value) {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  qb_id_->assign(value);
}
inline void ContactItem::set_qb_id(const char* value) {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  qb_id_->assign(value);
}
inline void ContactItem::set_qb_id(const char* value, size_t size) {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  qb_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_qb_id() {
  set_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    qb_id_ = new ::std::string;
  }
  return qb_id_;
}
inline ::std::string* ContactItem::release_qb_id() {
  clear_has_qb_id();
  if (qb_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qb_id_;
    qb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_qb_id(::std::string* qb_id) {
  if (qb_id_ != &::google::protobuf::internal::kEmptyString) {
    delete qb_id_;
  }
  if (qb_id) {
    set_has_qb_id();
    qb_id_ = qb_id;
  } else {
    clear_has_qb_id();
    qb_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string idb_key = 5;
inline bool ContactItem::has_idb_key() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContactItem::set_has_idb_key() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContactItem::clear_has_idb_key() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContactItem::clear_idb_key() {
  if (idb_key_ != &::google::protobuf::internal::kEmptyString) {
    idb_key_->clear();
  }
  clear_has_idb_key();
}
inline const ::std::string& ContactItem::idb_key() const {
  return *idb_key_;
}
inline void ContactItem::set_idb_key(const ::std::string& value) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(value);
}
inline void ContactItem::set_idb_key(const char* value) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(value);
}
inline void ContactItem::set_idb_key(const char* value, size_t size) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_idb_key() {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  return idb_key_;
}
inline ::std::string* ContactItem::release_idb_key() {
  clear_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idb_key_;
    idb_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_idb_key(::std::string* idb_key) {
  if (idb_key_ != &::google::protobuf::internal::kEmptyString) {
    delete idb_key_;
  }
  if (idb_key) {
    set_has_idb_key();
    idb_key_ = idb_key;
  } else {
    clear_has_idb_key();
    idb_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ctct_name = 6;
inline bool ContactItem::has_ctct_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContactItem::set_has_ctct_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContactItem::clear_has_ctct_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContactItem::clear_ctct_name() {
  if (ctct_name_ != &::google::protobuf::internal::kEmptyString) {
    ctct_name_->clear();
  }
  clear_has_ctct_name();
}
inline const ::std::string& ContactItem::ctct_name() const {
  return *ctct_name_;
}
inline void ContactItem::set_ctct_name(const ::std::string& value) {
  set_has_ctct_name();
  if (ctct_name_ == &::google::protobuf::internal::kEmptyString) {
    ctct_name_ = new ::std::string;
  }
  ctct_name_->assign(value);
}
inline void ContactItem::set_ctct_name(const char* value) {
  set_has_ctct_name();
  if (ctct_name_ == &::google::protobuf::internal::kEmptyString) {
    ctct_name_ = new ::std::string;
  }
  ctct_name_->assign(value);
}
inline void ContactItem::set_ctct_name(const void* value, size_t size) {
  set_has_ctct_name();
  if (ctct_name_ == &::google::protobuf::internal::kEmptyString) {
    ctct_name_ = new ::std::string;
  }
  ctct_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_ctct_name() {
  set_has_ctct_name();
  if (ctct_name_ == &::google::protobuf::internal::kEmptyString) {
    ctct_name_ = new ::std::string;
  }
  return ctct_name_;
}
inline ::std::string* ContactItem::release_ctct_name() {
  clear_has_ctct_name();
  if (ctct_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ctct_name_;
    ctct_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_ctct_name(::std::string* ctct_name) {
  if (ctct_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ctct_name_;
  }
  if (ctct_name) {
    set_has_ctct_name();
    ctct_name_ = ctct_name;
  } else {
    clear_has_ctct_name();
    ctct_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pinyin = 7;
inline bool ContactItem::has_pinyin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContactItem::set_has_pinyin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContactItem::clear_has_pinyin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContactItem::clear_pinyin() {
  if (pinyin_ != &::google::protobuf::internal::kEmptyString) {
    pinyin_->clear();
  }
  clear_has_pinyin();
}
inline const ::std::string& ContactItem::pinyin() const {
  return *pinyin_;
}
inline void ContactItem::set_pinyin(const ::std::string& value) {
  set_has_pinyin();
  if (pinyin_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_ = new ::std::string;
  }
  pinyin_->assign(value);
}
inline void ContactItem::set_pinyin(const char* value) {
  set_has_pinyin();
  if (pinyin_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_ = new ::std::string;
  }
  pinyin_->assign(value);
}
inline void ContactItem::set_pinyin(const char* value, size_t size) {
  set_has_pinyin();
  if (pinyin_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_ = new ::std::string;
  }
  pinyin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_pinyin() {
  set_has_pinyin();
  if (pinyin_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_ = new ::std::string;
  }
  return pinyin_;
}
inline ::std::string* ContactItem::release_pinyin() {
  clear_has_pinyin();
  if (pinyin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pinyin_;
    pinyin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_pinyin(::std::string* pinyin) {
  if (pinyin_ != &::google::protobuf::internal::kEmptyString) {
    delete pinyin_;
  }
  if (pinyin) {
    set_has_pinyin();
    pinyin_ = pinyin;
  } else {
    clear_has_pinyin();
    pinyin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pinyin_full = 8;
inline bool ContactItem::has_pinyin_full() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContactItem::set_has_pinyin_full() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContactItem::clear_has_pinyin_full() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ContactItem::clear_pinyin_full() {
  if (pinyin_full_ != &::google::protobuf::internal::kEmptyString) {
    pinyin_full_->clear();
  }
  clear_has_pinyin_full();
}
inline const ::std::string& ContactItem::pinyin_full() const {
  return *pinyin_full_;
}
inline void ContactItem::set_pinyin_full(const ::std::string& value) {
  set_has_pinyin_full();
  if (pinyin_full_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_full_ = new ::std::string;
  }
  pinyin_full_->assign(value);
}
inline void ContactItem::set_pinyin_full(const char* value) {
  set_has_pinyin_full();
  if (pinyin_full_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_full_ = new ::std::string;
  }
  pinyin_full_->assign(value);
}
inline void ContactItem::set_pinyin_full(const char* value, size_t size) {
  set_has_pinyin_full();
  if (pinyin_full_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_full_ = new ::std::string;
  }
  pinyin_full_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_pinyin_full() {
  set_has_pinyin_full();
  if (pinyin_full_ == &::google::protobuf::internal::kEmptyString) {
    pinyin_full_ = new ::std::string;
  }
  return pinyin_full_;
}
inline ::std::string* ContactItem::release_pinyin_full() {
  clear_has_pinyin_full();
  if (pinyin_full_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pinyin_full_;
    pinyin_full_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_pinyin_full(::std::string* pinyin_full) {
  if (pinyin_full_ != &::google::protobuf::internal::kEmptyString) {
    delete pinyin_full_;
  }
  if (pinyin_full) {
    set_has_pinyin_full();
    pinyin_full_ = pinyin_full;
  } else {
    clear_has_pinyin_full();
    pinyin_full_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inst_id = 9;
inline bool ContactItem::has_inst_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ContactItem::set_has_inst_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ContactItem::clear_has_inst_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ContactItem::clear_inst_id() {
  if (inst_id_ != &::google::protobuf::internal::kEmptyString) {
    inst_id_->clear();
  }
  clear_has_inst_id();
}
inline const ::std::string& ContactItem::inst_id() const {
  return *inst_id_;
}
inline void ContactItem::set_inst_id(const ::std::string& value) {
  set_has_inst_id();
  if (inst_id_ == &::google::protobuf::internal::kEmptyString) {
    inst_id_ = new ::std::string;
  }
  inst_id_->assign(value);
}
inline void ContactItem::set_inst_id(const char* value) {
  set_has_inst_id();
  if (inst_id_ == &::google::protobuf::internal::kEmptyString) {
    inst_id_ = new ::std::string;
  }
  inst_id_->assign(value);
}
inline void ContactItem::set_inst_id(const char* value, size_t size) {
  set_has_inst_id();
  if (inst_id_ == &::google::protobuf::internal::kEmptyString) {
    inst_id_ = new ::std::string;
  }
  inst_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_inst_id() {
  set_has_inst_id();
  if (inst_id_ == &::google::protobuf::internal::kEmptyString) {
    inst_id_ = new ::std::string;
  }
  return inst_id_;
}
inline ::std::string* ContactItem::release_inst_id() {
  clear_has_inst_id();
  if (inst_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inst_id_;
    inst_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_inst_id(::std::string* inst_id) {
  if (inst_id_ != &::google::protobuf::internal::kEmptyString) {
    delete inst_id_;
  }
  if (inst_id) {
    set_has_inst_id();
    inst_id_ = inst_id;
  } else {
    clear_has_inst_id();
    inst_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inst_code = 10;
inline bool ContactItem::has_inst_code() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ContactItem::set_has_inst_code() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ContactItem::clear_has_inst_code() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ContactItem::clear_inst_code() {
  if (inst_code_ != &::google::protobuf::internal::kEmptyString) {
    inst_code_->clear();
  }
  clear_has_inst_code();
}
inline const ::std::string& ContactItem::inst_code() const {
  return *inst_code_;
}
inline void ContactItem::set_inst_code(const ::std::string& value) {
  set_has_inst_code();
  if (inst_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_code_ = new ::std::string;
  }
  inst_code_->assign(value);
}
inline void ContactItem::set_inst_code(const char* value) {
  set_has_inst_code();
  if (inst_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_code_ = new ::std::string;
  }
  inst_code_->assign(value);
}
inline void ContactItem::set_inst_code(const char* value, size_t size) {
  set_has_inst_code();
  if (inst_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_code_ = new ::std::string;
  }
  inst_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_inst_code() {
  set_has_inst_code();
  if (inst_code_ == &::google::protobuf::internal::kEmptyString) {
    inst_code_ = new ::std::string;
  }
  return inst_code_;
}
inline ::std::string* ContactItem::release_inst_code() {
  clear_has_inst_code();
  if (inst_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inst_code_;
    inst_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_inst_code(::std::string* inst_code) {
  if (inst_code_ != &::google::protobuf::internal::kEmptyString) {
    delete inst_code_;
  }
  if (inst_code) {
    set_has_inst_code();
    inst_code_ = inst_code;
  } else {
    clear_has_inst_code();
    inst_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ctct_code = 11;
inline bool ContactItem::has_ctct_code() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ContactItem::set_has_ctct_code() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ContactItem::clear_has_ctct_code() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ContactItem::clear_ctct_code() {
  if (ctct_code_ != &::google::protobuf::internal::kEmptyString) {
    ctct_code_->clear();
  }
  clear_has_ctct_code();
}
inline const ::std::string& ContactItem::ctct_code() const {
  return *ctct_code_;
}
inline void ContactItem::set_ctct_code(const ::std::string& value) {
  set_has_ctct_code();
  if (ctct_code_ == &::google::protobuf::internal::kEmptyString) {
    ctct_code_ = new ::std::string;
  }
  ctct_code_->assign(value);
}
inline void ContactItem::set_ctct_code(const char* value) {
  set_has_ctct_code();
  if (ctct_code_ == &::google::protobuf::internal::kEmptyString) {
    ctct_code_ = new ::std::string;
  }
  ctct_code_->assign(value);
}
inline void ContactItem::set_ctct_code(const char* value, size_t size) {
  set_has_ctct_code();
  if (ctct_code_ == &::google::protobuf::internal::kEmptyString) {
    ctct_code_ = new ::std::string;
  }
  ctct_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_ctct_code() {
  set_has_ctct_code();
  if (ctct_code_ == &::google::protobuf::internal::kEmptyString) {
    ctct_code_ = new ::std::string;
  }
  return ctct_code_;
}
inline ::std::string* ContactItem::release_ctct_code() {
  clear_has_ctct_code();
  if (ctct_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ctct_code_;
    ctct_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_ctct_code(::std::string* ctct_code) {
  if (ctct_code_ != &::google::protobuf::internal::kEmptyString) {
    delete ctct_code_;
  }
  if (ctct_code) {
    set_has_ctct_code();
    ctct_code_ = ctct_code;
  } else {
    clear_has_ctct_code();
    ctct_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_vip = 12;
inline bool ContactItem::has_is_vip() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ContactItem::set_has_is_vip() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ContactItem::clear_has_is_vip() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ContactItem::clear_is_vip() {
  is_vip_ = false;
  clear_has_is_vip();
}
inline bool ContactItem::is_vip() const {
  return is_vip_;
}
inline void ContactItem::set_is_vip(bool value) {
  set_has_is_vip();
  is_vip_ = value;
}

// optional bool is_danger = 13;
inline bool ContactItem::has_is_danger() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ContactItem::set_has_is_danger() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ContactItem::clear_has_is_danger() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ContactItem::clear_is_danger() {
  is_danger_ = false;
  clear_has_is_danger();
}
inline bool ContactItem::is_danger() const {
  return is_danger_;
}
inline void ContactItem::set_is_danger(bool value) {
  set_has_is_danger();
  is_danger_ = value;
}

// optional string biz_type = 14;
inline bool ContactItem::has_biz_type() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ContactItem::set_has_biz_type() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ContactItem::clear_has_biz_type() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ContactItem::clear_biz_type() {
  if (biz_type_ != &::google::protobuf::internal::kEmptyString) {
    biz_type_->clear();
  }
  clear_has_biz_type();
}
inline const ::std::string& ContactItem::biz_type() const {
  return *biz_type_;
}
inline void ContactItem::set_biz_type(const ::std::string& value) {
  set_has_biz_type();
  if (biz_type_ == &::google::protobuf::internal::kEmptyString) {
    biz_type_ = new ::std::string;
  }
  biz_type_->assign(value);
}
inline void ContactItem::set_biz_type(const char* value) {
  set_has_biz_type();
  if (biz_type_ == &::google::protobuf::internal::kEmptyString) {
    biz_type_ = new ::std::string;
  }
  biz_type_->assign(value);
}
inline void ContactItem::set_biz_type(const char* value, size_t size) {
  set_has_biz_type();
  if (biz_type_ == &::google::protobuf::internal::kEmptyString) {
    biz_type_ = new ::std::string;
  }
  biz_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_biz_type() {
  set_has_biz_type();
  if (biz_type_ == &::google::protobuf::internal::kEmptyString) {
    biz_type_ = new ::std::string;
  }
  return biz_type_;
}
inline ::std::string* ContactItem::release_biz_type() {
  clear_has_biz_type();
  if (biz_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = biz_type_;
    biz_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_biz_type(::std::string* biz_type) {
  if (biz_type_ != &::google::protobuf::internal::kEmptyString) {
    delete biz_type_;
  }
  if (biz_type) {
    set_has_biz_type();
    biz_type_ = biz_type;
  } else {
    clear_has_biz_type();
    biz_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string update_time = 15;
inline bool ContactItem::has_update_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ContactItem::set_has_update_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ContactItem::clear_has_update_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ContactItem::clear_update_time() {
  if (update_time_ != &::google::protobuf::internal::kEmptyString) {
    update_time_->clear();
  }
  clear_has_update_time();
}
inline const ::std::string& ContactItem::update_time() const {
  return *update_time_;
}
inline void ContactItem::set_update_time(const ::std::string& value) {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::kEmptyString) {
    update_time_ = new ::std::string;
  }
  update_time_->assign(value);
}
inline void ContactItem::set_update_time(const char* value) {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::kEmptyString) {
    update_time_ = new ::std::string;
  }
  update_time_->assign(value);
}
inline void ContactItem::set_update_time(const char* value, size_t size) {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::kEmptyString) {
    update_time_ = new ::std::string;
  }
  update_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactItem::mutable_update_time() {
  set_has_update_time();
  if (update_time_ == &::google::protobuf::internal::kEmptyString) {
    update_time_ = new ::std::string;
  }
  return update_time_;
}
inline ::std::string* ContactItem::release_update_time() {
  clear_has_update_time();
  if (update_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = update_time_;
    update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactItem::set_allocated_update_time(::std::string* update_time) {
  if (update_time_ != &::google::protobuf::internal::kEmptyString) {
    delete update_time_;
  }
  if (update_time) {
    set_has_update_time();
    update_time_ = update_time;
  } else {
    clear_has_update_time();
    update_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Crm.AccountMappingItem account_mapping = 16;
inline int ContactItem::account_mapping_size() const {
  return account_mapping_.size();
}
inline void ContactItem::clear_account_mapping() {
  account_mapping_.Clear();
}
inline const ::Crm::AccountMappingItem& ContactItem::account_mapping(int index) const {
  return account_mapping_.Get(index);
}
inline ::Crm::AccountMappingItem* ContactItem::mutable_account_mapping(int index) {
  return account_mapping_.Mutable(index);
}
inline ::Crm::AccountMappingItem* ContactItem::add_account_mapping() {
  return account_mapping_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Crm::AccountMappingItem >&
ContactItem::account_mapping() const {
  return account_mapping_;
}
inline ::google::protobuf::RepeatedPtrField< ::Crm::AccountMappingItem >*
ContactItem::mutable_account_mapping() {
  return &account_mapping_;
}

// -------------------------------------------------------------------

// GetCtctListResponse

// optional .Crm.CommonResponseFields common_fields = 1;
inline bool GetCtctListResponse::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCtctListResponse::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCtctListResponse::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCtctListResponse::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonResponseFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonResponseFields& GetCtctListResponse::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonResponseFields* GetCtctListResponse::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonResponseFields;
  return common_fields_;
}
inline ::Crm::CommonResponseFields* GetCtctListResponse::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonResponseFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetCtctListResponse::set_allocated_common_fields(::Crm::CommonResponseFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// repeated .Crm.ContactItem result = 2;
inline int GetCtctListResponse::result_size() const {
  return result_.size();
}
inline void GetCtctListResponse::clear_result() {
  result_.Clear();
}
inline const ::Crm::ContactItem& GetCtctListResponse::result(int index) const {
  return result_.Get(index);
}
inline ::Crm::ContactItem* GetCtctListResponse::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::Crm::ContactItem* GetCtctListResponse::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Crm::ContactItem >&
GetCtctListResponse::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::Crm::ContactItem >*
GetCtctListResponse::mutable_result() {
  return &result_;
}

// -------------------------------------------------------------------

// GetAccountListRequest

// optional .Crm.CommonRequestFields common_fields = 1;
inline bool GetAccountListRequest::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAccountListRequest::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAccountListRequest::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAccountListRequest::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonRequestFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonRequestFields& GetAccountListRequest::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonRequestFields* GetAccountListRequest::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonRequestFields;
  return common_fields_;
}
inline ::Crm::CommonRequestFields* GetAccountListRequest::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonRequestFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetAccountListRequest::set_allocated_common_fields(::Crm::CommonRequestFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// -------------------------------------------------------------------

// AccountItem

// optional string crm_id = 1;
inline bool AccountItem::has_crm_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountItem::set_has_crm_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountItem::clear_has_crm_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountItem::clear_crm_id() {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    crm_id_->clear();
  }
  clear_has_crm_id();
}
inline const ::std::string& AccountItem::crm_id() const {
  return *crm_id_;
}
inline void AccountItem::set_crm_id(const ::std::string& value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void AccountItem::set_crm_id(const char* value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void AccountItem::set_crm_id(const char* value, size_t size) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountItem::mutable_crm_id() {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  return crm_id_;
}
inline ::std::string* AccountItem::release_crm_id() {
  clear_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crm_id_;
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountItem::set_allocated_crm_id(::std::string* crm_id) {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    delete crm_id_;
  }
  if (crm_id) {
    set_has_crm_id();
    crm_id_ = crm_id;
  } else {
    clear_has_crm_id();
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account_id = 2;
inline bool AccountItem::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountItem::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountItem::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountItem::clear_account_id() {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    account_id_->clear();
  }
  clear_has_account_id();
}
inline const ::std::string& AccountItem::account_id() const {
  return *account_id_;
}
inline void AccountItem::set_account_id(const ::std::string& value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AccountItem::set_account_id(const char* value) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(value);
}
inline void AccountItem::set_account_id(const char* value, size_t size) {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  account_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountItem::mutable_account_id() {
  set_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    account_id_ = new ::std::string;
  }
  return account_id_;
}
inline ::std::string* AccountItem::release_account_id() {
  clear_has_account_id();
  if (account_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_id_;
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountItem::set_allocated_account_id(::std::string* account_id) {
  if (account_id_ != &::google::protobuf::internal::kEmptyString) {
    delete account_id_;
  }
  if (account_id) {
    set_has_account_id();
    account_id_ = account_id;
  } else {
    clear_has_account_id();
    account_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string idb_key = 3;
inline bool AccountItem::has_idb_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountItem::set_has_idb_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountItem::clear_has_idb_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountItem::clear_idb_key() {
  if (idb_key_ != &::google::protobuf::internal::kEmptyString) {
    idb_key_->clear();
  }
  clear_has_idb_key();
}
inline const ::std::string& AccountItem::idb_key() const {
  return *idb_key_;
}
inline void AccountItem::set_idb_key(const ::std::string& value) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(value);
}
inline void AccountItem::set_idb_key(const char* value) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(value);
}
inline void AccountItem::set_idb_key(const char* value, size_t size) {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  idb_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountItem::mutable_idb_key() {
  set_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    idb_key_ = new ::std::string;
  }
  return idb_key_;
}
inline ::std::string* AccountItem::release_idb_key() {
  clear_has_idb_key();
  if (idb_key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idb_key_;
    idb_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountItem::set_allocated_idb_key(::std::string* idb_key) {
  if (idb_key_ != &::google::protobuf::internal::kEmptyString) {
    delete idb_key_;
  }
  if (idb_key) {
    set_has_idb_key();
    idb_key_ = idb_key;
  } else {
    clear_has_idb_key();
    idb_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 4;
inline bool AccountItem::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountItem::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountItem::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountItem::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& AccountItem::account() const {
  return *account_;
}
inline void AccountItem::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void AccountItem::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void AccountItem::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountItem::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* AccountItem::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountItem::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account_name = 5;
inline bool AccountItem::has_account_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountItem::set_has_account_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountItem::clear_has_account_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountItem::clear_account_name() {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    account_name_->clear();
  }
  clear_has_account_name();
}
inline const ::std::string& AccountItem::account_name() const {
  return *account_name_;
}
inline void AccountItem::set_account_name(const ::std::string& value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void AccountItem::set_account_name(const char* value) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(value);
}
inline void AccountItem::set_account_name(const char* value, size_t size) {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  account_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountItem::mutable_account_name() {
  set_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    account_name_ = new ::std::string;
  }
  return account_name_;
}
inline ::std::string* AccountItem::release_account_name() {
  clear_has_account_name();
  if (account_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_name_;
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountItem::set_allocated_account_name(::std::string* account_name) {
  if (account_name_ != &::google::protobuf::internal::kEmptyString) {
    delete account_name_;
  }
  if (account_name) {
    set_has_account_name();
    account_name_ = account_name;
  } else {
    clear_has_account_name();
    account_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string serial_number = 6;
inline bool AccountItem::has_serial_number() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountItem::set_has_serial_number() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountItem::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountItem::clear_serial_number() {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    serial_number_->clear();
  }
  clear_has_serial_number();
}
inline const ::std::string& AccountItem::serial_number() const {
  return *serial_number_;
}
inline void AccountItem::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void AccountItem::set_serial_number(const char* value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void AccountItem::set_serial_number(const char* value, size_t size) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountItem::mutable_serial_number() {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  return serial_number_;
}
inline ::std::string* AccountItem::release_serial_number() {
  clear_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_number_;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountItem::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  if (serial_number) {
    set_has_serial_number();
    serial_number_ = serial_number;
  } else {
    clear_has_serial_number();
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_code = 7;
inline bool AccountItem::has_role_code() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AccountItem::set_has_role_code() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AccountItem::clear_has_role_code() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AccountItem::clear_role_code() {
  if (role_code_ != &::google::protobuf::internal::kEmptyString) {
    role_code_->clear();
  }
  clear_has_role_code();
}
inline const ::std::string& AccountItem::role_code() const {
  return *role_code_;
}
inline void AccountItem::set_role_code(const ::std::string& value) {
  set_has_role_code();
  if (role_code_ == &::google::protobuf::internal::kEmptyString) {
    role_code_ = new ::std::string;
  }
  role_code_->assign(value);
}
inline void AccountItem::set_role_code(const char* value) {
  set_has_role_code();
  if (role_code_ == &::google::protobuf::internal::kEmptyString) {
    role_code_ = new ::std::string;
  }
  role_code_->assign(value);
}
inline void AccountItem::set_role_code(const char* value, size_t size) {
  set_has_role_code();
  if (role_code_ == &::google::protobuf::internal::kEmptyString) {
    role_code_ = new ::std::string;
  }
  role_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountItem::mutable_role_code() {
  set_has_role_code();
  if (role_code_ == &::google::protobuf::internal::kEmptyString) {
    role_code_ = new ::std::string;
  }
  return role_code_;
}
inline ::std::string* AccountItem::release_role_code() {
  clear_has_role_code();
  if (role_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_code_;
    role_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountItem::set_allocated_role_code(::std::string* role_code) {
  if (role_code_ != &::google::protobuf::internal::kEmptyString) {
    delete role_code_;
  }
  if (role_code) {
    set_has_role_code();
    role_code_ = role_code;
  } else {
    clear_has_role_code();
    role_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string team_ids = 8;
inline int AccountItem::team_ids_size() const {
  return team_ids_.size();
}
inline void AccountItem::clear_team_ids() {
  team_ids_.Clear();
}
inline const ::std::string& AccountItem::team_ids(int index) const {
  return team_ids_.Get(index);
}
inline ::std::string* AccountItem::mutable_team_ids(int index) {
  return team_ids_.Mutable(index);
}
inline void AccountItem::set_team_ids(int index, const ::std::string& value) {
  team_ids_.Mutable(index)->assign(value);
}
inline void AccountItem::set_team_ids(int index, const char* value) {
  team_ids_.Mutable(index)->assign(value);
}
inline void AccountItem::set_team_ids(int index, const char* value, size_t size) {
  team_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountItem::add_team_ids() {
  return team_ids_.Add();
}
inline void AccountItem::add_team_ids(const ::std::string& value) {
  team_ids_.Add()->assign(value);
}
inline void AccountItem::add_team_ids(const char* value) {
  team_ids_.Add()->assign(value);
}
inline void AccountItem::add_team_ids(const char* value, size_t size) {
  team_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
AccountItem::team_ids() const {
  return team_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
AccountItem::mutable_team_ids() {
  return &team_ids_;
}

// -------------------------------------------------------------------

// GetAccountListResponse

// optional .Crm.CommonResponseFields common_fields = 1;
inline bool GetAccountListResponse::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetAccountListResponse::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetAccountListResponse::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetAccountListResponse::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonResponseFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonResponseFields& GetAccountListResponse::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonResponseFields* GetAccountListResponse::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonResponseFields;
  return common_fields_;
}
inline ::Crm::CommonResponseFields* GetAccountListResponse::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonResponseFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetAccountListResponse::set_allocated_common_fields(::Crm::CommonResponseFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// repeated .Crm.AccountItem result = 2;
inline int GetAccountListResponse::result_size() const {
  return result_.size();
}
inline void GetAccountListResponse::clear_result() {
  result_.Clear();
}
inline const ::Crm::AccountItem& GetAccountListResponse::result(int index) const {
  return result_.Get(index);
}
inline ::Crm::AccountItem* GetAccountListResponse::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::Crm::AccountItem* GetAccountListResponse::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Crm::AccountItem >&
GetAccountListResponse::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::Crm::AccountItem >*
GetAccountListResponse::mutable_result() {
  return &result_;
}

// -------------------------------------------------------------------

// GetRoleListRequest

// optional .Crm.CommonRequestFields common_fields = 1;
inline bool GetRoleListRequest::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRoleListRequest::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRoleListRequest::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRoleListRequest::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonRequestFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonRequestFields& GetRoleListRequest::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonRequestFields* GetRoleListRequest::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonRequestFields;
  return common_fields_;
}
inline ::Crm::CommonRequestFields* GetRoleListRequest::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonRequestFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetRoleListRequest::set_allocated_common_fields(::Crm::CommonRequestFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// -------------------------------------------------------------------

// RoleItem

// optional string crm_id = 1;
inline bool RoleItem::has_crm_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleItem::set_has_crm_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleItem::clear_has_crm_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleItem::clear_crm_id() {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    crm_id_->clear();
  }
  clear_has_crm_id();
}
inline const ::std::string& RoleItem::crm_id() const {
  return *crm_id_;
}
inline void RoleItem::set_crm_id(const ::std::string& value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void RoleItem::set_crm_id(const char* value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void RoleItem::set_crm_id(const char* value, size_t size) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleItem::mutable_crm_id() {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  return crm_id_;
}
inline ::std::string* RoleItem::release_crm_id() {
  clear_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crm_id_;
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleItem::set_allocated_crm_id(::std::string* crm_id) {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    delete crm_id_;
  }
  if (crm_id) {
    set_has_crm_id();
    crm_id_ = crm_id;
  } else {
    clear_has_crm_id();
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_code = 2;
inline bool RoleItem::has_role_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleItem::set_has_role_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleItem::clear_has_role_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleItem::clear_role_code() {
  if (role_code_ != &::google::protobuf::internal::kEmptyString) {
    role_code_->clear();
  }
  clear_has_role_code();
}
inline const ::std::string& RoleItem::role_code() const {
  return *role_code_;
}
inline void RoleItem::set_role_code(const ::std::string& value) {
  set_has_role_code();
  if (role_code_ == &::google::protobuf::internal::kEmptyString) {
    role_code_ = new ::std::string;
  }
  role_code_->assign(value);
}
inline void RoleItem::set_role_code(const char* value) {
  set_has_role_code();
  if (role_code_ == &::google::protobuf::internal::kEmptyString) {
    role_code_ = new ::std::string;
  }
  role_code_->assign(value);
}
inline void RoleItem::set_role_code(const char* value, size_t size) {
  set_has_role_code();
  if (role_code_ == &::google::protobuf::internal::kEmptyString) {
    role_code_ = new ::std::string;
  }
  role_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleItem::mutable_role_code() {
  set_has_role_code();
  if (role_code_ == &::google::protobuf::internal::kEmptyString) {
    role_code_ = new ::std::string;
  }
  return role_code_;
}
inline ::std::string* RoleItem::release_role_code() {
  clear_has_role_code();
  if (role_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_code_;
    role_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleItem::set_allocated_role_code(::std::string* role_code) {
  if (role_code_ != &::google::protobuf::internal::kEmptyString) {
    delete role_code_;
  }
  if (role_code) {
    set_has_role_code();
    role_code_ = role_code;
  } else {
    clear_has_role_code();
    role_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string role_name = 3;
inline bool RoleItem::has_role_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleItem::set_has_role_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleItem::clear_has_role_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleItem::clear_role_name() {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    role_name_->clear();
  }
  clear_has_role_name();
}
inline const ::std::string& RoleItem::role_name() const {
  return *role_name_;
}
inline void RoleItem::set_role_name(const ::std::string& value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void RoleItem::set_role_name(const char* value) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(value);
}
inline void RoleItem::set_role_name(const char* value, size_t size) {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  role_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoleItem::mutable_role_name() {
  set_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    role_name_ = new ::std::string;
  }
  return role_name_;
}
inline ::std::string* RoleItem::release_role_name() {
  clear_has_role_name();
  if (role_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = role_name_;
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoleItem::set_allocated_role_name(::std::string* role_name) {
  if (role_name_ != &::google::protobuf::internal::kEmptyString) {
    delete role_name_;
  }
  if (role_name) {
    set_has_role_name();
    role_name_ = role_name;
  } else {
    clear_has_role_name();
    role_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetRoleListResponse

// optional .Crm.CommonResponseFields common_fields = 1;
inline bool GetRoleListResponse::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRoleListResponse::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRoleListResponse::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRoleListResponse::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonResponseFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonResponseFields& GetRoleListResponse::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonResponseFields* GetRoleListResponse::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonResponseFields;
  return common_fields_;
}
inline ::Crm::CommonResponseFields* GetRoleListResponse::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonResponseFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetRoleListResponse::set_allocated_common_fields(::Crm::CommonResponseFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// repeated .Crm.RoleItem result = 2;
inline int GetRoleListResponse::result_size() const {
  return result_.size();
}
inline void GetRoleListResponse::clear_result() {
  result_.Clear();
}
inline const ::Crm::RoleItem& GetRoleListResponse::result(int index) const {
  return result_.Get(index);
}
inline ::Crm::RoleItem* GetRoleListResponse::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::Crm::RoleItem* GetRoleListResponse::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Crm::RoleItem >&
GetRoleListResponse::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::Crm::RoleItem >*
GetRoleListResponse::mutable_result() {
  return &result_;
}

// -------------------------------------------------------------------

// GetTeamListRequest

// optional .Crm.CommonRequestFields common_fields = 1;
inline bool GetTeamListRequest::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTeamListRequest::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTeamListRequest::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTeamListRequest::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonRequestFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonRequestFields& GetTeamListRequest::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonRequestFields* GetTeamListRequest::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonRequestFields;
  return common_fields_;
}
inline ::Crm::CommonRequestFields* GetTeamListRequest::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonRequestFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetTeamListRequest::set_allocated_common_fields(::Crm::CommonRequestFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// -------------------------------------------------------------------

// TeamItem

// optional string crm_id = 1;
inline bool TeamItem::has_crm_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamItem::set_has_crm_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamItem::clear_has_crm_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamItem::clear_crm_id() {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    crm_id_->clear();
  }
  clear_has_crm_id();
}
inline const ::std::string& TeamItem::crm_id() const {
  return *crm_id_;
}
inline void TeamItem::set_crm_id(const ::std::string& value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void TeamItem::set_crm_id(const char* value) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(value);
}
inline void TeamItem::set_crm_id(const char* value, size_t size) {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  crm_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamItem::mutable_crm_id() {
  set_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    crm_id_ = new ::std::string;
  }
  return crm_id_;
}
inline ::std::string* TeamItem::release_crm_id() {
  clear_has_crm_id();
  if (crm_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crm_id_;
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamItem::set_allocated_crm_id(::std::string* crm_id) {
  if (crm_id_ != &::google::protobuf::internal::kEmptyString) {
    delete crm_id_;
  }
  if (crm_id) {
    set_has_crm_id();
    crm_id_ = crm_id;
  } else {
    clear_has_crm_id();
    crm_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string team_id = 2;
inline bool TeamItem::has_team_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamItem::set_has_team_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamItem::clear_has_team_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamItem::clear_team_id() {
  if (team_id_ != &::google::protobuf::internal::kEmptyString) {
    team_id_->clear();
  }
  clear_has_team_id();
}
inline const ::std::string& TeamItem::team_id() const {
  return *team_id_;
}
inline void TeamItem::set_team_id(const ::std::string& value) {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  team_id_->assign(value);
}
inline void TeamItem::set_team_id(const char* value) {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  team_id_->assign(value);
}
inline void TeamItem::set_team_id(const char* value, size_t size) {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  team_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamItem::mutable_team_id() {
  set_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    team_id_ = new ::std::string;
  }
  return team_id_;
}
inline ::std::string* TeamItem::release_team_id() {
  clear_has_team_id();
  if (team_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = team_id_;
    team_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamItem::set_allocated_team_id(::std::string* team_id) {
  if (team_id_ != &::google::protobuf::internal::kEmptyString) {
    delete team_id_;
  }
  if (team_id) {
    set_has_team_id();
    team_id_ = team_id;
  } else {
    clear_has_team_id();
    team_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes team_name = 3;
inline bool TeamItem::has_team_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamItem::set_has_team_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamItem::clear_has_team_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamItem::clear_team_name() {
  if (team_name_ != &::google::protobuf::internal::kEmptyString) {
    team_name_->clear();
  }
  clear_has_team_name();
}
inline const ::std::string& TeamItem::team_name() const {
  return *team_name_;
}
inline void TeamItem::set_team_name(const ::std::string& value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::kEmptyString) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
}
inline void TeamItem::set_team_name(const char* value) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::kEmptyString) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(value);
}
inline void TeamItem::set_team_name(const void* value, size_t size) {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::kEmptyString) {
    team_name_ = new ::std::string;
  }
  team_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamItem::mutable_team_name() {
  set_has_team_name();
  if (team_name_ == &::google::protobuf::internal::kEmptyString) {
    team_name_ = new ::std::string;
  }
  return team_name_;
}
inline ::std::string* TeamItem::release_team_name() {
  clear_has_team_name();
  if (team_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = team_name_;
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamItem::set_allocated_team_name(::std::string* team_name) {
  if (team_name_ != &::google::protobuf::internal::kEmptyString) {
    delete team_name_;
  }
  if (team_name) {
    set_has_team_name();
    team_name_ = team_name;
  } else {
    clear_has_team_name();
    team_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes team_code = 4;
inline bool TeamItem::has_team_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamItem::set_has_team_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamItem::clear_has_team_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamItem::clear_team_code() {
  if (team_code_ != &::google::protobuf::internal::kEmptyString) {
    team_code_->clear();
  }
  clear_has_team_code();
}
inline const ::std::string& TeamItem::team_code() const {
  return *team_code_;
}
inline void TeamItem::set_team_code(const ::std::string& value) {
  set_has_team_code();
  if (team_code_ == &::google::protobuf::internal::kEmptyString) {
    team_code_ = new ::std::string;
  }
  team_code_->assign(value);
}
inline void TeamItem::set_team_code(const char* value) {
  set_has_team_code();
  if (team_code_ == &::google::protobuf::internal::kEmptyString) {
    team_code_ = new ::std::string;
  }
  team_code_->assign(value);
}
inline void TeamItem::set_team_code(const void* value, size_t size) {
  set_has_team_code();
  if (team_code_ == &::google::protobuf::internal::kEmptyString) {
    team_code_ = new ::std::string;
  }
  team_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamItem::mutable_team_code() {
  set_has_team_code();
  if (team_code_ == &::google::protobuf::internal::kEmptyString) {
    team_code_ = new ::std::string;
  }
  return team_code_;
}
inline ::std::string* TeamItem::release_team_code() {
  clear_has_team_code();
  if (team_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = team_code_;
    team_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamItem::set_allocated_team_code(::std::string* team_code) {
  if (team_code_ != &::google::protobuf::internal::kEmptyString) {
    delete team_code_;
  }
  if (team_code) {
    set_has_team_code();
    team_code_ = team_code;
  } else {
    clear_has_team_code();
    team_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes desc = 5;
inline bool TeamItem::has_desc() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeamItem::set_has_desc() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeamItem::clear_has_desc() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeamItem::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& TeamItem::desc() const {
  return *desc_;
}
inline void TeamItem::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void TeamItem::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void TeamItem::set_desc(const void* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamItem::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* TeamItem::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamItem::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GetTeamListResponse

// optional .Crm.CommonResponseFields common_fields = 1;
inline bool GetTeamListResponse::has_common_fields() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTeamListResponse::set_has_common_fields() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTeamListResponse::clear_has_common_fields() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTeamListResponse::clear_common_fields() {
  if (common_fields_ != NULL) common_fields_->::Crm::CommonResponseFields::Clear();
  clear_has_common_fields();
}
inline const ::Crm::CommonResponseFields& GetTeamListResponse::common_fields() const {
  return common_fields_ != NULL ? *common_fields_ : *default_instance_->common_fields_;
}
inline ::Crm::CommonResponseFields* GetTeamListResponse::mutable_common_fields() {
  set_has_common_fields();
  if (common_fields_ == NULL) common_fields_ = new ::Crm::CommonResponseFields;
  return common_fields_;
}
inline ::Crm::CommonResponseFields* GetTeamListResponse::release_common_fields() {
  clear_has_common_fields();
  ::Crm::CommonResponseFields* temp = common_fields_;
  common_fields_ = NULL;
  return temp;
}
inline void GetTeamListResponse::set_allocated_common_fields(::Crm::CommonResponseFields* common_fields) {
  delete common_fields_;
  common_fields_ = common_fields;
  if (common_fields) {
    set_has_common_fields();
  } else {
    clear_has_common_fields();
  }
}

// repeated .Crm.TeamItem result = 2;
inline int GetTeamListResponse::result_size() const {
  return result_.size();
}
inline void GetTeamListResponse::clear_result() {
  result_.Clear();
}
inline const ::Crm::TeamItem& GetTeamListResponse::result(int index) const {
  return result_.Get(index);
}
inline ::Crm::TeamItem* GetTeamListResponse::mutable_result(int index) {
  return result_.Mutable(index);
}
inline ::Crm::TeamItem* GetTeamListResponse::add_result() {
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Crm::TeamItem >&
GetTeamListResponse::result() const {
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::Crm::TeamItem >*
GetTeamListResponse::mutable_result() {
  return &result_;
}

// -------------------------------------------------------------------

// AccountUpdateEvent

// optional string eventType = 1;
inline bool AccountUpdateEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountUpdateEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountUpdateEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountUpdateEvent::clear_eventtype() {
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    eventtype_->clear();
  }
  clear_has_eventtype();
}
inline const ::std::string& AccountUpdateEvent::eventtype() const {
  return *eventtype_;
}
inline void AccountUpdateEvent::set_eventtype(const ::std::string& value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void AccountUpdateEvent::set_eventtype(const char* value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void AccountUpdateEvent::set_eventtype(const char* value, size_t size) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountUpdateEvent::mutable_eventtype() {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  return eventtype_;
}
inline ::std::string* AccountUpdateEvent::release_eventtype() {
  clear_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventtype_;
    eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountUpdateEvent::set_allocated_eventtype(::std::string* eventtype) {
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    delete eventtype_;
  }
  if (eventtype) {
    set_has_eventtype();
    eventtype_ = eventtype;
  } else {
    clear_has_eventtype();
    eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Crm.AccountItem account = 2;
inline bool AccountUpdateEvent::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountUpdateEvent::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountUpdateEvent::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountUpdateEvent::clear_account() {
  if (account_ != NULL) account_->::Crm::AccountItem::Clear();
  clear_has_account();
}
inline const ::Crm::AccountItem& AccountUpdateEvent::account() const {
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::Crm::AccountItem* AccountUpdateEvent::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::Crm::AccountItem;
  return account_;
}
inline ::Crm::AccountItem* AccountUpdateEvent::release_account() {
  clear_has_account();
  ::Crm::AccountItem* temp = account_;
  account_ = NULL;
  return temp;
}
inline void AccountUpdateEvent::set_allocated_account(::Crm::AccountItem* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
}

// -------------------------------------------------------------------

// TeamUpdateEvent

// optional string eventType = 1;
inline bool TeamUpdateEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamUpdateEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamUpdateEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamUpdateEvent::clear_eventtype() {
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    eventtype_->clear();
  }
  clear_has_eventtype();
}
inline const ::std::string& TeamUpdateEvent::eventtype() const {
  return *eventtype_;
}
inline void TeamUpdateEvent::set_eventtype(const ::std::string& value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void TeamUpdateEvent::set_eventtype(const char* value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void TeamUpdateEvent::set_eventtype(const char* value, size_t size) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamUpdateEvent::mutable_eventtype() {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  return eventtype_;
}
inline ::std::string* TeamUpdateEvent::release_eventtype() {
  clear_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventtype_;
    eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TeamUpdateEvent::set_allocated_eventtype(::std::string* eventtype) {
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    delete eventtype_;
  }
  if (eventtype) {
    set_has_eventtype();
    eventtype_ = eventtype;
  } else {
    clear_has_eventtype();
    eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Crm.TeamItem team = 2;
inline bool TeamUpdateEvent::has_team() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamUpdateEvent::set_has_team() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamUpdateEvent::clear_has_team() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamUpdateEvent::clear_team() {
  if (team_ != NULL) team_->::Crm::TeamItem::Clear();
  clear_has_team();
}
inline const ::Crm::TeamItem& TeamUpdateEvent::team() const {
  return team_ != NULL ? *team_ : *default_instance_->team_;
}
inline ::Crm::TeamItem* TeamUpdateEvent::mutable_team() {
  set_has_team();
  if (team_ == NULL) team_ = new ::Crm::TeamItem;
  return team_;
}
inline ::Crm::TeamItem* TeamUpdateEvent::release_team() {
  clear_has_team();
  ::Crm::TeamItem* temp = team_;
  team_ = NULL;
  return temp;
}
inline void TeamUpdateEvent::set_allocated_team(::Crm::TeamItem* team) {
  delete team_;
  team_ = team;
  if (team) {
    set_has_team();
  } else {
    clear_has_team();
  }
}

// -------------------------------------------------------------------

// InstitutionUpdateEvent

// optional string eventType = 1;
inline bool InstitutionUpdateEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstitutionUpdateEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstitutionUpdateEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstitutionUpdateEvent::clear_eventtype() {
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    eventtype_->clear();
  }
  clear_has_eventtype();
}
inline const ::std::string& InstitutionUpdateEvent::eventtype() const {
  return *eventtype_;
}
inline void InstitutionUpdateEvent::set_eventtype(const ::std::string& value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void InstitutionUpdateEvent::set_eventtype(const char* value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void InstitutionUpdateEvent::set_eventtype(const char* value, size_t size) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstitutionUpdateEvent::mutable_eventtype() {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  return eventtype_;
}
inline ::std::string* InstitutionUpdateEvent::release_eventtype() {
  clear_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventtype_;
    eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstitutionUpdateEvent::set_allocated_eventtype(::std::string* eventtype) {
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    delete eventtype_;
  }
  if (eventtype) {
    set_has_eventtype();
    eventtype_ = eventtype;
  } else {
    clear_has_eventtype();
    eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Crm.InstitutionItem institution = 2;
inline bool InstitutionUpdateEvent::has_institution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstitutionUpdateEvent::set_has_institution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstitutionUpdateEvent::clear_has_institution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstitutionUpdateEvent::clear_institution() {
  if (institution_ != NULL) institution_->::Crm::InstitutionItem::Clear();
  clear_has_institution();
}
inline const ::Crm::InstitutionItem& InstitutionUpdateEvent::institution() const {
  return institution_ != NULL ? *institution_ : *default_instance_->institution_;
}
inline ::Crm::InstitutionItem* InstitutionUpdateEvent::mutable_institution() {
  set_has_institution();
  if (institution_ == NULL) institution_ = new ::Crm::InstitutionItem;
  return institution_;
}
inline ::Crm::InstitutionItem* InstitutionUpdateEvent::release_institution() {
  clear_has_institution();
  ::Crm::InstitutionItem* temp = institution_;
  institution_ = NULL;
  return temp;
}
inline void InstitutionUpdateEvent::set_allocated_institution(::Crm::InstitutionItem* institution) {
  delete institution_;
  institution_ = institution;
  if (institution) {
    set_has_institution();
  } else {
    clear_has_institution();
  }
}

// -------------------------------------------------------------------

// ContactUpdateEvent

// optional string eventType = 1;
inline bool ContactUpdateEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactUpdateEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactUpdateEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactUpdateEvent::clear_eventtype() {
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    eventtype_->clear();
  }
  clear_has_eventtype();
}
inline const ::std::string& ContactUpdateEvent::eventtype() const {
  return *eventtype_;
}
inline void ContactUpdateEvent::set_eventtype(const ::std::string& value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void ContactUpdateEvent::set_eventtype(const char* value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void ContactUpdateEvent::set_eventtype(const char* value, size_t size) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactUpdateEvent::mutable_eventtype() {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  return eventtype_;
}
inline ::std::string* ContactUpdateEvent::release_eventtype() {
  clear_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventtype_;
    eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactUpdateEvent::set_allocated_eventtype(::std::string* eventtype) {
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    delete eventtype_;
  }
  if (eventtype) {
    set_has_eventtype();
    eventtype_ = eventtype;
  } else {
    clear_has_eventtype();
    eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Crm.ContactItem contact = 2;
inline bool ContactUpdateEvent::has_contact() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactUpdateEvent::set_has_contact() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactUpdateEvent::clear_has_contact() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactUpdateEvent::clear_contact() {
  if (contact_ != NULL) contact_->::Crm::ContactItem::Clear();
  clear_has_contact();
}
inline const ::Crm::ContactItem& ContactUpdateEvent::contact() const {
  return contact_ != NULL ? *contact_ : *default_instance_->contact_;
}
inline ::Crm::ContactItem* ContactUpdateEvent::mutable_contact() {
  set_has_contact();
  if (contact_ == NULL) contact_ = new ::Crm::ContactItem;
  return contact_;
}
inline ::Crm::ContactItem* ContactUpdateEvent::release_contact() {
  clear_has_contact();
  ::Crm::ContactItem* temp = contact_;
  contact_ = NULL;
  return temp;
}
inline void ContactUpdateEvent::set_allocated_contact(::Crm::ContactItem* contact) {
  delete contact_;
  contact_ = contact;
  if (contact) {
    set_has_contact();
  } else {
    clear_has_contact();
  }
}

// -------------------------------------------------------------------

// ManagerUpdateEvent

// optional string eventType = 1;
inline bool ManagerUpdateEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManagerUpdateEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManagerUpdateEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManagerUpdateEvent::clear_eventtype() {
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    eventtype_->clear();
  }
  clear_has_eventtype();
}
inline const ::std::string& ManagerUpdateEvent::eventtype() const {
  return *eventtype_;
}
inline void ManagerUpdateEvent::set_eventtype(const ::std::string& value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void ManagerUpdateEvent::set_eventtype(const char* value) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(value);
}
inline void ManagerUpdateEvent::set_eventtype(const char* value, size_t size) {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  eventtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ManagerUpdateEvent::mutable_eventtype() {
  set_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    eventtype_ = new ::std::string;
  }
  return eventtype_;
}
inline ::std::string* ManagerUpdateEvent::release_eventtype() {
  clear_has_eventtype();
  if (eventtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = eventtype_;
    eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ManagerUpdateEvent::set_allocated_eventtype(::std::string* eventtype) {
  if (eventtype_ != &::google::protobuf::internal::kEmptyString) {
    delete eventtype_;
  }
  if (eventtype) {
    set_has_eventtype();
    eventtype_ = eventtype;
  } else {
    clear_has_eventtype();
    eventtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Crm.AccountMappingItem mappings = 2;
inline int ManagerUpdateEvent::mappings_size() const {
  return mappings_.size();
}
inline void ManagerUpdateEvent::clear_mappings() {
  mappings_.Clear();
}
inline const ::Crm::AccountMappingItem& ManagerUpdateEvent::mappings(int index) const {
  return mappings_.Get(index);
}
inline ::Crm::AccountMappingItem* ManagerUpdateEvent::mutable_mappings(int index) {
  return mappings_.Mutable(index);
}
inline ::Crm::AccountMappingItem* ManagerUpdateEvent::add_mappings() {
  return mappings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Crm::AccountMappingItem >&
ManagerUpdateEvent::mappings() const {
  return mappings_;
}
inline ::google::protobuf::RepeatedPtrField< ::Crm::AccountMappingItem >*
ManagerUpdateEvent::mutable_mappings() {
  return &mappings_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Crm

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CrmProto_2eproto__INCLUDED
